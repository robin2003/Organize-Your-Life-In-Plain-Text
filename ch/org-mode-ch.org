#+TITLE: Org Mode - Organize Your Life In Plain Text!
#+LANGUAGE:  en
#+AUTHOR: Bernt Hansen (IRC: BerntH on freenode)
#+EMAIL: bernt@norang.ca
#+OPTIONS:   H:3 num:t   toc:3 \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:nil
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+OPTIONS:   author:t creator:t timestamp:t email:t
#+DESCRIPTION: A description of how I currently use org-mode
#+KEYWORDS:  org-mode Emacs organization GTD getting-things-done git
#+SEQ_TODO: FIXME FIXED
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

org-mode 是由Carsten Dominik开发的,可以通过纯文本操作的，难以置信的组织管理
工具，org-mode也是Emacs的一部分。

* 如何使用该文档
:PROPERTIES:
:CUSTOM_ID: HowToUseThisDocument
:END:
[2012-11-24 Sat 23:28]

在使用该文档时，假设你已经对org-mode有一些了解，比如agenda，capture模式等。
这样就不会对org-mode太陌生。更多org-mode相关的信息
可以参考[[http://orgmode.org/index.html#sec-4.1][Org-Mode使用手册]]
也可以通过浏览[[http://orgmode.org/worg/][Worg Site]]网站来获取。

我一直使用org-mode作为个人信息管理工具多年了。刚开始只是少量使用 =TODO=
和 =DONE= 这些关键字。随着时间推移，我又做了一些针对自己工作流的定制化，
所有的这些定制化都包含在这篇文档中。

我也会经常修改自己的工作流程，并且尝试些新奇的功能。本文将主要包含的则是我当
前使用的比较成熟的org-mode设置。我会每隔30天来将新尝试的工作流设置修改更新
到这个文档中（假设在此期间这些设置还在使用）因此，通过这种方式样保证新的流程
能够有机会变得成熟。

本文是通过org 文件编写，可以在emacs中打开该文件，通过执行tangle的快捷键
=C-c C-v C-t= 在当前目录生成elisp脚本文件org-mode.el。tangle 命令将会提取所有
elisp 代码段到该lisp文件中，因此可以在你的.emacs配置文件引用这些配置, 从而能够快速
使用这些配置。

* 版权
:PROPERTIES:
:CUSTOM_ID: License
:END:
[2011-11-19 Sat 21:53] 

#+begin_example
Copyright (C)  2013  Bernt Hansen.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
  
Code in this document is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation, either
version 3 of the License, or (at your option) any later version.
  
This code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#+end_example

本文http://doc.norang.ca/org-mode.html(无论是[[http://doc.norang.ca/org-mode.html][HTML format]]
还是Org format)都是遵循GNU自由文档协议1.3或者以上版本。

而所有代码示例以及CSS风格代码段都是遵循GNU General Public License v3或者以上版本。

* 修改记录 - 一些新东西
:PROPERTIES:
:CUSTOM_ID: ChangeHistory
:END:

#+name: org-mode-doc-version
#+begin_src sh :exports none
#!/bin/sh
git describe --abbrev=4
#+end_src

#+name: org-mode-version
#+begin_src sh :exports none
cd ~/git/org-mode && git describe HEAD
#+end_src

本文档版本信息可以通过调用call_org-mode-doc-version()获取.本文由 =org-mode= 自带
的发布功能生成，org mode版本库通过call_org-mode-version()获取.

本文源代码可从[[http://doc.norang.ca/org-mode.org][文本org文件]]获取。我会争取
每个月更新一次该文档。

所有文档的修改记录可以从如下链接获取：
[[http://git.norang.ca/?p%3Dorg-mode-doc.git%3Ba%3Dsummary][git://git.norang.ca/org-mode-doc.git]].

* 开始
:PROPERTIES:
:CUSTOM_ID: GettingStarted
:END:

=org-mode= 非常容易入门。你所需要做的就是在emacs配置文件添加几行配置就可以使用 =git= 仓库中
最新的org-mode了。

** 通过Git来安装org-mode
:PROPERTIES:
:CUSTOM_ID: GettingOrgModeWithGit
:END:
[2012-06-24 Sun 11:21]

我通常会在本地=~/git/log-mode/=下克隆一份 org-mode源码。克隆源码命令如下：
#+begin_src sh
cd ~/git
git clone git://orgmode.org/org-mode.git
#+end_src

可以通过如下命令来获取并编译org-mode开发者提交的最新的更新：
#+begin_src sh
cd ~/git/org-mode
git pull
make uncompiled
#+end_src

我通常在设置中使用没有编译的源码，因此未编译的 =make= 目标已经足够使用了。

通常本地的org仓库源码跟踪远程仓库的 =master= 分支的更新。

** Org-Mode 设置
:PROPERTIES:
:CUSTOM_ID: Setup
:END:

如下的在我.emacs配置文件中的代码段，在我大部分的缓冲区都开启了=org-mode=。
对于后缀为 =.org=, =.org_archive= 以及 =.txt=文件， =org-mode= 是默认的应用模式。

#+header: :tangle no
#+begin_src emacs-lisp
;;;
;;; Org Mode
;;;
(add-to-list 'load-path (expand-file-name "~/git/org-mode/lisp"))
(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
(require 'org)

#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp :exports none
;; The following setting is different from the document so that you
;; can override the document path by setting your path in the variable
;; org-mode-user-lisp-path
;;
(if (boundp 'org-mode-user-lisp-path)
    (add-to-list 'load-path org-mode-user-lisp-path)
  (add-to-list 'load-path (expand-file-name "~/git/org-mode/lisp")))

(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
(require 'org)
;;
;; Standard key bindings
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
#+end_src

以上就是所有开始阶段你需要做的配置来在org-mode中使用标题以及列表。

本文其他的部分，将描述我定制化的设置，我如何来组织org-mode相关的文件，以及一些为
了更符合我的工作习惯而做的修改。

** 用org文件来管理日常
:PROPERTIES:
:CUSTOM_ID: OrgFiles
:END:

任务可以被分解为多个逻辑组或者项目。可以用不同的org文件来管理大的任务组
可以通过不同子目录来组织管理隶属于不同项目的多个文件。

如下是我在生活中使用的文件。

如下的org 文件来管理与工作无关的任务:

| Filename     | Description                                |
|--------------+--------------------------------------------|
| todo.org     | Personal tasks and things to keep track of |
| gsoc2009.org | Google Summer of Code stuff for 2009       |
| farm.org     | Farm related tasks                         |
| mark.org     | Tasks related to my son Mark               |
| org.org      | Org-mode related tasks                     |
| git.org      | Git related tasks                          |

如下的org文件则来管理org capture相关的记录以及任务：

| Filename   | Description         |
|------------+---------------------|
| refile.org | Capture task bucket |

如下是工作相关的org文件，来跟踪工作相关的记录以及事件（描述中的真实客户名称已
经被隐藏）

| Filename    | Description                             |
|-------------+-----------------------------------------|
| norang.org  | Norang tasks and notes                  |
| XYZ.org     | XYZ Corp tasks and notes                |
| ABC.org     | ABC Ltd tasks                           |
| ABC-DEF.org | ABC Ltd tasks for their client DEF Corp |
| ABC-KKK.org | ABC Ltd tasks for their client KKK Inc  |
| YYY.org     | YYY Inc tasks                           |

在处理多个客户以及多个客户相关项目时org-mode让我得心应手。一个org文件就可以记录
完成一个客户以及一个项目所有信息。

如上表，我负责客户ABC公司多个系统。将不同客户分到不同的org文件管理，能够保持所有
事情更加具有逻辑性，也方便在org agenda中过滤以及添加需要显示在agenda视图中的信息。

其他的org文件只用作发布，这些文件并不会添加到org agenda管理范畴，更多细节，可以
参考  [[#Publishing][发布导出章节]] 。

** 日程表设置
:PROPERTIES:
:CUSTOM_ID: AgendaSetup
:END:

下面是我当前的=org-agenda-files=配置。
#+header: :tangle no
#+begin_src emacs-lisp
(setq org-agenda-files (quote ("~/git/org"
                               "~/git/org/client1"
                               "~/git/client2")))
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp :exports none
;; The following setting is different from the document so that you
;; can override the document org-agenda-files by setting your
;; org-agenda-files in the variable org-user-agenda-files
;;
(if (boundp 'org-user-agenda-files)
    (setq org-agenda-files org-user-agenda-files)
  (setq org-agenda-files (quote ("~/git/org"
                               "~/git/org/client1"
                               "~/git/client2"))))
#+end_src

=org-mode= 可以通过快捷键 =C-c [= 以及 = C-c ]= 来配置变量 =org-agenda-files= 变量，
从而可以增加以及删除agenda管理文件。 但是这些命令会将我的默认配置的路径列表替换成
文件，我并不希望这样，因为如果这样，后面在这些路径添加的文件将不会自动纳入agenda管理。
这样会导致有些文件没法通过agenda跟踪，从而导致自己错过一些非常重要的提醒。

我现在已经将快捷键 =C-c [= 以及 =C-c ]= 在 =org-mode-hook= 中禁用了，这样就可以阻止
上面提到情况发生。通常我只会手工的对 =org-agenda-files= 变量设置路径参数。但是
修改这个变量中路径情况还是很少发生的，因为只要添加新文件到这些已经存在的路径，这些
文件就会被agenda自动管理起来。

我同时也会禁用注释快捷键 =C-c ;= 因为从来不用它。但是有时候在我编辑代码块时候，
会不小心误碰,因此把它禁用了。

上个例子中，我把路径 =~/git/client2= 放到另一个叫 ~/git/org的git仓库中。这样
我就可以用它来处理一些个人的事情。我会在不同的机器上同步这些信息，如果在非该客户
机器上，我会跳过这些隐私信息。我会在不同机器上同步我个人信息，但是并不会同步客户
相关信息，所以 =org-agenda-files= 在自己机器上并不会包含 =~/git/client2= 目录。

** Org文件结构
:PROPERTIES:
:CUSTOM_ID: OrgFileStructure
:END:

大部分我的org文件第一层作为标题来对任务项目分类。 任务以及项目从第二层开始。

这是我org file第一层标题示例

=todo.org=:
- Special Dates

  Includes level 2 headings for

  - Birthdays
  - Anniversaries
  - Holidays

- Finances
- Health and Recreation
- House Maintenance
- Lawn and Garden Maintenance
- Notes
- Tasks
- Vehicle Maintenance
- Passwords

=norang.org=:

- System Maintenance
- Payroll
- Accounting
- Finances
- Hardware Maintenance
- Tasks
- Research and Development
- Notes
- Purchase Order Tracking
- Passwords

第一层任务通常都会设置 =property drawer= 用来指定该任务在该类型树中的分类。
通常我的org文件第一层标题设置如下

#+begin_src org :exports src
,* Health and Recreation
  :PROPERTIES:
  :CATEGORY: Health
  :END:
  ...
,* House Maintenance
  :PROPERTIES:
  :CATEGORY: House
  :END:
#+end_src

** 按键绑定
:PROPERTIES:
:CUSTOM_ID: KeyBindings
:END:

由于我高度依赖agenda.为使得能够更快速启动agenda, 我又将 =F12= 也绑定到 =org-agenda= 功能上，
这样会比 =C-c a= 更加快速，由于我每天会查看agenda上百次，这样节省了很多时间。

| 按键     | 功能                                            | 频率       |
|---------+-------------------------------------------------+------------|
| F12     | 日程 (比 C-c a 少按一个键 )                       | Very Often |
| C-c b   | 切换到org 文件                                   | Very Often |
| F11     | 切换到下一个计时任务(需要STARTED状态）             | Very Often |
| C-c c   | 捕获事件                                         | Very Often |
| C-F11   | 任务启动计时                                     | Often      |
| f9 g    | Gnus - 经常需要检查邮件                           | Often      |
| f5      | 显示所有todo状态的任务                            | Often      |
| S-f5    | Widen                                           | Often      |
| f9 b    | bbdb快捷键                                       | Often      |
| f9 c    | 日历快捷键                                       | Often      |
| C-S-f12 | 保存并发布项目                                   | Often      |
| C-c l   | 将链接存储，并作为候选                            | Often      |
| f8      | 查看下个agenda文件                               | Sometimes  |
| f9 r    | 引用选择区域(note:没有这个函数)                   | Sometimes  |
| f9 t    | 插入非激活状态时间（note:没有这个函数）            | Sometimes  |
| f9 v    | 切换选择模式 (显示和编辑链接)                      | Sometimes  |
| C-f9    | 上个缓冲区                                       | Sometimes  |
| C-f10   | 下个缓冲区                                       | Sometimes  |
| C-x n r | 限定显示区域(note:widen反操作)                    | Sometimes  |
| f9 f    | 引用插入文件                             | Sometimes  |
| f9 i    | 显示消息                                       | Sometimes  |
| f9 I    | 批量计时(note:没有这个函数)                                  | Sometimes  |
| f9 O    | 批量取消计时(note:没有这个函数)                                 | Sometimes  |
| f9 o    | 启动草稿模式                    | Sometimes  |
| f9 s    | 切换到草稿模式                        | Sometimes  |
| f9 h    | 隐藏其他任务                                | Rare       |
| f7      | 切换行分割                     | Rare       |
| f9 T    | 切换激活时间戳                | Rare       |
| C-c a   | 启动日程 (减少emacs 测试)            | Rare       |

* 任务和状态
:PROPERTIES:
:CUSTOM_ID: TasksAndStates
:END:

我使用一组TODO关键字来管理所有我的org文件。org-mode也可以为每个文件都定义一组
TODO关键字，但是我觉得定制一套全局的TODO关键字已经非常方便了，这样我就可以在不同文件中
用相同的设置。

但是本文是个特例:) 因为我不希望 =org-mode= 隐藏 =TODO= 关键字当它出现在标题中时。
我在文本开头处设置一个 =#+SEQ_TODO: FIXME_FIXED= 项，来保证在这个文档中 =TODO=
关键字不要隐藏。

** TODO 关键字
:PROPERTIES:
:CUSTOM_ID: TodoKeywords
:END:

我在emacs中使用的是亮色模式。因为亮色模式在阳光下更容易阅读。

下面是我的 =TODO= 状态关键字以及颜色设置elisp脚本：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold)
              ("MEETING" :foreground "forest green" :weight bold)
              ("PHONE" :foreground "forest green" :weight bold))))
#+end_src

*** 任务状态转换
:PROPERTIES:
:CUSTOM_ID: TodoKeywordTaskStates
:END:

任务状态开始于 =TODO= 结束于 =DONE=.

下图显示了可能的状态转换关系:

#+begin_src plantuml :file normal_task_states.png :cache yes
title Task States
[*] -> TODO
TODO -> NEXT
TODO -> DONE
NEXT -> DONE
DONE -> [*]
TODO --> WAITING
WAITING --> TODO
NEXT --> WAITING
WAITING --> NEXT
HOLD --> CANCELLED
WAITING --> CANCELLED
CANCELLED --> [*]
TODO --> HOLD
HOLD --> TODO
TODO --> CANCELLED
TODO: t
NEXT: n
DONE: d
WAITING:w
note right of WAITING: Note records\nwhat it is waiting for
HOLD:h
note right of CANCELLED: Note records\nwhy it was cancelled
CANCELLED:c
WAITING --> DONE
#+end_src

#+results[61c867b8eb4f49bc47e44ec2b534ac3219d82594]:
[[file:normal_task_states.png]]

*** 项目任务状态
:PROPERTIES:
:CUSTOM_ID: TodoKeywordProjectTaskStates
:END:

我的项目任务状态定义非常简单。我不想人为的明确的定义'这是一个项目' 以及 '这不是个项目'.
我对项目定义就是如果任务下有TODO关键字定义的子任务，那么它就是个项目。

项目可以定义在任何层级-只要定义一个带有TODO关键字的任务并且在下面定义一个带TODO关键字的子
任务那么这个任务就可以视为项目。项目和任务使用同一套关键字。如果一个子任务被标记 =NEXT=
那么这个项目就不会出现在阻塞任务列表中。

*** 回电
:PROPERTIES:
:CUSTOM_ID: TodoKeywordPhoneCalls
:END:

回电比较特别。回电任务在capture中创建时状态时为DONE状态。回电计时当任务创建时开始计时。如果我
需要看一些其他详细资料，需要关闭刚刚捕获的任务，直接使用快捷键 =C-c C-c= 先关闭捕获的任务
(停止计时) 然后通过 =f9 SPC= 重新恢复之前计时。

#+begin_src plantuml :file phone_states.png :cache yes
title Phone Call Task State
[*] -> PHONE
PHONE -> [*]
#+end_src

#+results[9e27f3a56c4fca8f05455e6dfa1282030ae52830]:
[[file:phone_states.png]]

*** 会议
:PROPERTIES:
:CUSTOM_ID: TodoKeywordMeetings
:END:

会议也是特殊的一个任务流程。会议事件在capture中创建时初始状态为done。当我需要中
断手上工作去提个问题或者需要开个会讨论问题，我会创建会议任务。会议任务处理和回电
任务非常相似，我会记录下我花了多少时间在开会上，并且会记录下讨论内容
（无论会议中还是会议后），长度以及复杂度。

会议计时从capture中创建该会议任务开始，如果需要转向查看其他任务，想提前关闭这个捕获
任务。我会先通过快捷键 =C-c C-c= 完成捕获，先关闭并保存这个捕获的任务(停止计时)
之后，通过 =f9 SPC= 来恢复会议计时。

#+begin_src plantuml :file meeting_states.png :cache yes
title Meeting Task State
[*] -> MEETING
MEETING -> [*]
#+end_src

#+results[942fb408787905ffcdde421ee02edabdbb921b06]:
[[file:meeting_states.png]]

** 快速TODO状态选择
:PROPERTIES:
:CUSTOM_ID: FastTodoSelection
:END:

快速TODO状态选择允许将任务TODO状态直接切换到其他状态通过按键菜单选择相应的快捷键。
这是个很棒的功能。

#+header: :tangle yes
#+begin_src emacs-lisp 
(setq org-use-fast-todo-selection t)
#+end_src

通过快捷键 =C-c C-t KEY= 来快速切换任务状态。

其中的 =KEY= 是定义在 =org-todo-keywords= 中的快速状态选择键。

如下设置：
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src

允许通过 =S-left= 以及 =S-right= 跳过一些常规操作，而直接循环切换任务状态而不会设置时间戳，当需要调整
任务状态时候，这个功能特别好用。

** TODO 状态触发
:PROPERTIES:
:CUSTOM_ID: ToDoStateTriggers
:END:

我定义了一些触发器，当一个任务状态切换时候，就会自动为该任务添加一个tag。举个例子，
当一个任务被设置到 =CANCELLED= 状态，那么触发器就会为该任务添加一个 =CANCELLED= 标签，
当又将该任务设置回 =TODO=状态，相应的 =CANCELLED= 标签也会自动移除。为任务自动添加标签，
会对后续在agenda视图中过滤任务有帮助,后续我也会详细介绍。

这些触发器自动添加标签遵循如下几条规则：

- 将一个任务设置 =CANCELLED= 状态，会自动添加 =CANCELLED= 标签
- 将一个任务设置 =WAITING= 状态，会自动添加 =WAITING= 标签
- 将一个任务设置 =HOLD= 状态，会自动添加 =WAITING= 和 =HOLD= 标签
- 当任务设置为完成状态，将会移除 =WAITING= 以及 =HOLD= 标签
- 将一个任务设置 =TODO= 状态，会自动删除 =WAITING= ， =CANCELLED= 以及 =HOLD= 标签
- 将一个任务设置 =NEXT= 状态，会自动删除 =WAITING= ， =CANCELLED= 以及 =HOLD= 标签
- 将一个任务设置 =DONE= 状态，会自动删除 =WAITING= ， =CANCELLED= 以及 =HOLD= 标签

这些自动生成的标签将对在agenda中过滤任务带来极大便利, 如下是自动添加标签的lisp脚本。

#+header: :tangle yes
#+begin_src emacs-lisp 
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("HOLD" ("WAITING" .t) ("HOLD" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+end_src

* 通过capture来快速添加一个新任务
:PROPERTIES:
:CUSTOM_ID: Capture
:END:

org capture mode取代了 remember mode 用来捕获任务以及备忘录。

为使得添加任务更加有效率，我定义了最少的capture模板，曾经我预定义了很多capture模板，
甚至每个org文件都定义一个模板。我通过绑定的快捷键 =C-c c= 来启动org-capture功能，然后
选择一个合适的模板，并且将捕获的内容写进合适的文件的 =* Tasks= 分类下面。

我发现我还得将这些capture的任务写入到不同的org文件的不同位置，因此发现定义这么多capture
模板更本没法帮助我。因此我修改了我的工作流，使用最少的capture模板--这样我创建任务将会非常快
并且只要重新提取到特定文件一次。当然这样也节省了我维护我org-capture模板的时间，尤其当需要新加
org文件时候。

** capture 模板
:PROPERTIES:
:CUSTOM_ID: CaptureTemplates
:END:

当需要添加一个新任务时候，我会将新任务归入如下几类模板中的一种：

- 要回个电话(p)
- 要开个会(m)
- 要回个邮件(r)
- 添加新任务(t)
- 添加新备忘(n)
- 突发事情(j)
- 新兴趣(h)

然后再选择相应模板。

如下是我的capture 模板的配置：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-directory "~/git/org")
(setq org-default-notes-file "~/git/org/refile.org")

;; I use C-c c to start capture mode
(global-set-key (kbd "C-c c") 'org-capture)

;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
(setq org-capture-templates
      (quote (("t" "todo" entry (file "~/git/org/refile.org")
               "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
              ("r" "respond" entry (file "~/git/org/refile.org")
               "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
              ("n" "note" entry (file "~/git/org/refile.org")
               "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
              ("j" "Journal" entry (file+datetree "~/git/org/diary.org")
               "* %?\n%U\n" :clock-in t :clock-resume t)
              ("w" "org-protocol" entry (file "~/git/org/refile.org")
               "* TODO Review %c\n%U\n" :immediate-finish t)
              ("m" "Meeting" entry (file "~/git/org/refile.org")
               "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
              ("p" "Phone call" entry (file "~/git/org/refile.org")
               "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
              ("h" "Habit" entry (file "~/git/org/refile.org")
               "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n"))))
#+end_src

capture mode能够对新建任务自动处理计时与终止计时。该功能是capture自带功能并不需要新添加
代码来实现该功能。当我启动capture mode创建的任务，任务通过指定 =:clock-in t=
就可以自动开始计时，当任务通过快捷键 =C-c C-c= 将任务写入文件时候,会重新从原来计时的任务开始计时。

通过capture mode创建的那种快速完成的计时任务，当短时间结束时(通常少于1分钟) 会在我的任务里边
产生一个空的计时抽屉，而这个空的计时抽屉不是特别有用。因此我会将如下计时抽屉给删除掉。

#+begin_src org :exports src
,* TODO New Capture Task
  :LOGBOOK:
  :END:
  [2010-05-08 Sat 13:53]
#+end_src

我使用如下自定义的函数来移除这些在 =LOGBOOK= 生成的空的计时日志。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Remove empty LOGBOOK drawers on clock out
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at "LOGBOOK" (point))))

(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)

#+end_src

** 多个capture任务文件
:PROPERTIES:
:CUSTOM_ID: CaptureRefileOrg
:END:

我只使用一个org 文件来作为我capture模板的目标文件。

我会在这个命名为 =refine.org= 文件中存备忘，任务，回电以及org-protocol相关的任务. 曾经也用过多个文件，但是
发现多个文件并没有什么优势。

通常这个文件是空的，除了第一行创建了 =REFILE= 标签。

这个文件唯一的一行永久存在的内容如下:
#+begin_src org :exports src
,#+FILETAGS: REFILE
#+end_src

** capture 任务需要快速
:PROPERTIES:
:CUSTOM_ID: CaptureTasksAreFast
:END:

好了， 当我正在做些事情时候-我需要记住它。我不想停下手上的事。我可能在孵化一个项目，
通常我不希望脱离当前聚焦的事情，但是同时我又不想错过新来的的事情。

这时我该怎么办？通过 =C-c c= 启动capture mode然后选择 =t= ,然后我的buffer中会产
生一个如下格式的任务：

#+begin_src org :exports src
,* TODO 
  [2010-08-05 Thu 21:06]

  [[file:~/git/org-mode-doc/org-mode.org::*Capture%20Tasks%20is%20all%20about%20being%20FAST][Capture Tasks is all about being FAST]]
#+end_src

在新生成的TODO任务中写入新来的任务细节，然后 =C-c C-c= 这条任务就会写入refile.org文件。
然后我就可以继续当前手上工作，同时之前任务也不会丢失，我此时也不必花精力去考虑新来的任务。

对于capture任务note更新时间会记录下来。capture模板自动设置计时以及停止计时。这对突然的
打断以及回电话非常有用。

* 重定向任务
:PROPERTIES:
:CUSTOM_ID: Refiling
:END:

重定向任务很简单。当我的refile.org文件中通过capture mode积累了一堆任务之后。
我需要将这些任务移动到正确的org文件的合适分类中。我所有的在用的org文件都通过
=org-agenda-files= 变量定义，都可以在agenda中显示。

我有时候会在refile.org文件中累积长达1周的capture任务。在agenda
视图中显示出来的当日任务，我通常当天就重定向到其他文件中。我喜欢
保持重定向任务列表是空的。

** 重定向任务设置
:PROPERTIES:
:CUSTOM_ID: RefileSetup
:END:

为重定向任务到新的org文件中，你需要知道这些任务应该重定向到哪里。

我的设置中，会将 =org-agenda-files= 定义的文件以及当前文件作为重定向的目标。

我现在使用IDO来完成目标查找。我发现IDO处理起来比之前的设置更加快。刚开始我并不喜欢IDO，
但是当看了些相关的文档后，了解到 =C-SPEC= 可以限制目标搜搜数量，我发现它比我之前设置好
用多了。现在，当我想重定向refile文件中的任务时候，我只需要执行快捷键 =C-c C-w= 启动重定向流程,
然后输入一些匹配字段，然后执行 =C-SPC= 限制到匹配到当前列表，然后继续查找其他目标。 =C-j= 可以选择
当前的作为目标。我喜欢这样。我通常显示所有的目标文件大纲列表，因此我可以拥有相同的头在不同子树下
或者不同项目中，并且当重定向时也能够方便区分。

当前我会将 =DONE= 状态任务作为有效重定向任务。这样可以保证重定向目标合适大小。

我的重定向配置如下:
#+header: :tangle yes
#+begin_src emacs-lisp
; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))

; Use full outline paths for refile targets - we file directly with IDO
(setq org-refile-use-outline-path t)

; Targets complete directly with IDO
(setq org-outline-path-complete-in-steps nil)

; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

; Use IDO for both buffer and file completion and ido-everywhere to t
(setq org-completion-use-ido t)
(setq ido-everywhere t)
(setq ido-max-directory-size 100000)
(ido-mode (quote both))
; Use the current window when visiting files and buffers with ido
(setq ido-default-file-method 'selected-window)
(setq ido-default-buffer-method 'selected-window)
; Use the current window for indirect buffer display
(setq org-indirect-buffer-display 'current-window)

;;;; Refile settings
; Exclude DONE state tasks from refile targets
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+end_src

为了将任务重定向到 =norang.or= 文件，我通常将光标移到需要重定向的任务上，然后执行
=C-c C-w= ，然后执行 =nor C-SPC sys RET= 就可以完成了。IDO 补全模式让定位目标非常方便。

** 重定向任务
:PROPERTIES:
:CUSTOM_ID: RefilingTasks
:END:

需要重定向的任务都在agenda的特定块中。为快速找到需要重定向的任务，我先通过 =F12 SPC= 打开
agenda视图，然后滚动到第二节： =Tasks to Refile= . 该视图中显示所有的任务(即使有些任务已经
被标记为=donw=状态)

在agenda中批量将任务重定向到相同位置也是非常方便。只要列出所有需要批量重定向任务，然后通过
=m= 标记这些任务，最后执行 =B r= 将会将所有标记的task重定向到新的目标。通常，我也会通过执行
=C-2 C-c C-w= 重定向当前任务作为当前计时任务的子任务.

执行重定向耗时通常在1分钟以内，因此我每天都会重定向好几次。

** 重定向备忘
:PROPERTIES:
:CUSTOM_ID: RefilingNotes
:END:

我通常在大部分org 文件中保留 =* Notes= 类型。备忘通常通过capture模板创建，同时会
给任务加上 =NOTE= 标签，由于有标签，所以方便通过agenda在不同文件快速查找。

备忘首先会创建在 =refile.org= 文件中，然后通过重定向功能重定向到合适项目文件中。有些项目
相关备忘会重定向到相应的项目任务下面，而非 =* NOTES= 大纲中。这种备忘通常只和该项目相关，
通常项目结束后就没太大用处了--当归档项目时候，删除这些备忘也没什么关系。

** 重定向回电以及会议
:PROPERTIES:
:CUSTOM_ID: RefilingPhoneCalls
:END:

回电以及会议任务也是通过capture mode来创建的。在通过capture mode 模板创建这种任务时
会启动计时，当回电完成或者会议结束，计时也会结束。

回电以及会议任务也是生成到 =refile.org= 中，然后通过重定向功能定向到合适的位置。
有些是项目相关的回电，我们也希望在合适的分类中跟踪。我会重定向回电以及会议任务到合适
项目中，这样跟踪以及报告会更加精确。

* 定制化agenda视图
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViews
:END:

我定制了一个囊括所有的agenda视图。我也保留了另一个简单的agenda视图，该视图通常工作在我比较慢的
Eee PC上 - 因为它太慢了。我通常会花很多时间来简化agenda视图，同时希望agenda视图囊括所有东西。

我曾经大部分的定制化agenda视图已经不再使用，自从新的 =org-mode= 引入了过滤功能后。现在的agenda视图，
可以把所有东西都绑定在单一的视图里边。

定制化agenda视图使用场景:
- 单个agenda视图显示下列信息
  - 当天概览
  - 方便找到需要重定向的任务
  - 方便找到无法推进的项目
  - 方便找到下一个需要执行的任务
  - 查看项目情况
  - 查看任务依赖
  - 查看需要归档的任务
- 查找备忘
- 查看爱好

如果需要查看当天的日历通过 =F12 a= 会比生成块agenda要快 - 但是当我需要查看一周或者
一个月需要关注的信息，或者查看任务计时数据。只有在这种情况我才会生成块视图，否则我也不想花
很多时间等它生成。

** 设置
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewSetup
:END:

#+header: :tangle yes
#+begin_src emacs-lisp
;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

;; Custom agenda command definitions
(setq org-agenda-custom-commands
      (quote (("N" "Notes" tags "NOTE"
               ((org-agenda-overriding-header "Notes")
                (org-tags-match-list-sublevels t)))
              ("h" "Habits" tags-todo "STYLE=\"habit\""
               ((org-agenda-overriding-header "Habits")
                (org-agenda-sorting-strategy
                 '(todo-state-down effort-up category-keep))))
              (" " "Agenda"
               ((agenda "" nil)
                (tags "REFILE"
                      ((org-agenda-overriding-header "Tasks to Refile")
                       (org-tags-match-list-sublevels nil)))
                (tags-todo "-CANCELLED/!"
                           ((org-agenda-overriding-header "Stuck Projects")
                            (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-HOLD-CANCELLED/!"
                           ((org-agenda-overriding-header "Projects")
                            (org-agenda-skip-function 'bh/skip-non-projects)
                            (org-tags-match-list-sublevels 'indented)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED/!NEXT"
                           ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                            (org-tags-match-list-sublevels t)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(todo-state-down effort-up category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Project Subtasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-non-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED+WAITING|HOLD/!"
                           ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-non-tasks)
                            (org-tags-match-list-sublevels nil)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))
                (tags "-REFILE/"
                      ((org-agenda-overriding-header "Tasks to Archive")
                       (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                       (org-tags-match-list-sublevels nil))))
               nil))))

#+end_src

我的agenda视图如果范围不限制在项目中，大致看上去就是这样。该视图显示最上层层级项目以及 =NEXT= 任务，
由于当前没有聚焦单个项目所以项目的细节被隐藏了。

*注意* 该agenda视图截图并不是我目前使用的视图，有些老了，跟文档中描述的设置有些差异，后续会上传新的。


[[file:block-agenda-nonproject.png]]

当选定一个项目（在agenda中通过快捷键 =P= 选定）agenda块视图切换到显示项目以及子项目信息。相反如果不选定一个项目，那么与
项目无关的就被隐藏了。

这使得很容易聚焦手上的任务。

*注意* 目前这个agenda截屏有点老，跟文档中描述的设置有些差异，后续会替换掉这个图片。

[[file:block-agenda-project.png]]

通常我是从上到下处理agenda上的任务。因为有截止日期以及计划任务(往往是当天或者更早计划)都是显示
在最上方。

我每个工作日工作流程如下：
- Punch in(对于默认的任务会自动启动计时)
- 打开agenda视图,对今天哪些重要事情需要处理做到心中有数
- 读邮件查看新闻
  - 通过org-capture创建需要响应的备忘以及任务
- 查看重定向任务以及回复邮件
- 查看我的agenda视图，开始处理今天重要任务
  - 对任务启动计时
  - 将其完成，并设置为 =DONE= 状态，当然有可能被中断
- 继续完成其他任务
- 对于打断的任务，创建journal任务入口( =C-c c j= )
- Punch out，吃完午饭继续 punch in
- 完成更多任务
- 清空重定向任务
  - 通过 =m= 选定多个具有相同目标任务
  - 通过 =B r= 批量重定向标记的任务
  - 对所有任务重复上述动作(或者对单个任务做重定向 命令 =C-c C-w=)
    直到所有任务重定向完成。
- 将习惯标记完成状态
- Punch out工作日结束

** 我是如何选择接下来的任务
:PROPERTIES:
:CUSTOM_ID: WhatDoIWorkOnNext
:END:

首先会从agenda视图中选择处理今日截止的以及今天计划的或者之前计划的任务。然后开始着手处理
在 =Next Tasks= 列表中的任务。我通常会将当前所做的项目设置为今天的任务，这样这些项目就会
显示在每日agenda中，并能够提醒我需要及时完成他们。每次我也只会将一到两个项目添加到当日agenda视图
中显示，对于不是特别重要的项目并不会在当日agenda显示，这样能保证当日agenda视图不会因为任务太多分
散我的注意力。

当我需要转向新任务处理时候，我会执行 =F12 SPC= 启动agenda视图，并按照如下优先级处理：

- 从当日agenda选择任务
  - 截止日期是今天的(优先处理-还不是特别晚)
  - 已过截止日期的任务（有点晚）
  - 计划今日完成任务（计划今日完成的）
  - 依然在agenda中显示的计划任务
  - 将会截止的任务
- 选择 =NEXT= 状态任务
- 如果找不到 =NEXT= 状态的任务，从当前项目选择一个任务继续执行.

*** 为什么将任务都显示在 =NEXT= 列表
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewsNextList
:END:

我已经尝试一种新的时间管理方法处理事情。现在我只用一个 =NEXT= 列表。对于新创建项目
或者在项目中新建一个 =NEXT= 状态任务时候，该项目才会标记为 =NEXT= 状态。对于标记
=NEXT= 状态任务，它表示该任务 /现在/ 可以着手处理的任务，从逻辑上讲，表示项目接下来
需要做的事情。

我曾经还为任务定义 =ONGOING= 状态任务，这种状态的任务表示我花了些时间，但是还没有
真正着手开始。我有个专门的agenda视图来查看 =ONGOING= 任务，这样我就能快速从中找到
接下来着手处理的任务。

但现在我已经将 =ONGOING= 状态已经从我的状态列表中移除了。在agenda视图中显示的 =NEXT=
状态任务就可以表示将要着手处理的任务了-我就不需要再去检查 =ONGOING= 列表同时还去检查
=NEXT= 状态任务列表了。=NEXT= 列表中的任务表示这些任务完成后，项目也可以继续前进。
我希望事情能够快速找到下一步需要执行的任务 - 因此不要把时间花在在不同的org文件中查找任务
上面，这也是为什么我只保留 =NEXT= 任务列表，不再使用 =ONGOING= 列表原因。

** 读邮件， 新闻组， 以及通过IRC交流
:PROPERTIES:
:CUSTOM_ID: ReadingMailNewsIRC
:END:

当读邮件，看新闻组以及通过IRC沟通时我会给默认任务（通常是 =** Organization= ）启动
计时来记录在该项任务中花了多长时间。当查看邮件时，我会去Gnus然后查看收件箱中的所有邮件
。当有些邮件需要响应时候，我会通过org-capture创建标题为'回复 <用户>'新任务， 这样它能够
容易找到。有些邮件可以快速回复，但是有些邮件需要花点时间研究甚至会花很多时间才能完成。
对于那些需要记录计时信息的任务，我会先创建它，然后对它计时。对于通过capture模板创建的需要
回复的任务类型当前都是计划今日开始。因此这些任务可以一直保留着不会丢失。

接着，我通过快捷键 =F12 a= 启动视图，然后在agenda视图中对这个任务计时并处理它们。
一直重复直到所有 ‘对客户响应' 任务完成，标记任务状态为 =DONE= 为止。

我在Gnus中读邮件以及新闻组，因此我不需要对这种阅读任务另外计时(已经通过默认任务计时)。如果需
要记住的文章我会通过快捷键 =C-c c n= 创建一个note任务。基本上不用花时间，我也知道这个note也会存盘
(保存在refile.org中)，不会丢失。仅仅花了些捕获note的时间而已。

** 过滤
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFiltering
:END:

时间很短，但是任务很多。通常我在一个时候会有很多任务(现在有373个)。那么多任务需要查看
令人望而生畏。这时候agenda 过滤功能将派上用场。

现在是11:53AM 我依然在工作。我不希望看到与工作无关的任务。我也不想在午餐前花时间做个
大项目。。。因此我需要找到小工作量的任务，然后可以着手该任务。

怎么可以做到这点呢？先从ageda视图中获取所有NEXT状态的任务，然后通过过滤来缩小范围。
任务是按照工作量来排序的，因此排在最上的就是工作量最小的--只要做最上面的任务，然后依次
向下。我可以通过 =/ + 1= 限制显示工作量在10分钟以内的,这样就可以既完成任务也不用耽误
吃午饭。

*** 通过 / RET 自动移除带有上下文的任务
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFilteringContext
:END:

=/ RET= 在agenda中非常有用。这个功能是由John Wiegley添加进org-mode中的。它可以执行
用户自定义的过滤器，过滤掉不想显示的任务。

在工作中，假如我正在做个项目经理指派给我的任务。假如说有更重要事情来了，手上项目需要推迟到
后面处理。意味着我需要停下手上的工作。我会先在项目任务添加 =HOLD= 标签，然后去做优先级更
高的任务。当执行 =/ RET= 被标记 =HOLD= 的任务以及子任务将会被过滤掉(因为标签会继承)。

在家我会给我的一些任务标记上 =farm= 因为这些任务需要在我家农场里亲自处理。如果我不在
农场，我会通过这个功能将带有该标签的任务将会从agenda中自动过滤掉。当我在农场时候，我可以通过快捷键
=/ TAB farm RET= 来显示出这些任务。

如下是我的设置，来实现 =/ RET= 上面描述的使用场景。

#+header: :tangle yes
#+begin_src emacs-lisp
(defun bh/org-auto-exclude-function (tag)
  "Automatic task exclusion in the agenda with / RET"
  (and (cond
        ((string= tag "hold")
         t)
        ((string= tag "farm")
         t))
       (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
#+end_src

这样我就可以通过执行 =/ RET= 在agenda中将我暂时无法工作的任务先过滤掉。
这使得我的agenda更加简洁有序。

* 计时
:PROPERTIES:
:CUSTOM_ID: Clocking
:END:

是的，我承认我非常喜欢计时功能，我对计时功能非常着迷。

工作中，所有的任务都会计时。org-mode让计时非常简单。我宁愿选择过多计时，也不希望
少用计时，并且我发现在emacs中养成计时习惯也非常简单。

通过计时，方便在一天结束回头看看在哪个任务上花时间比较多，或者看在某个项目上花的时间
不够。同时也非常方便以后来评估一个事情花多长时间--你可以参考相似的任务来帮助你做
评估。

如果没有计时功能，很难来准确评估什么事情花多长时间。

我现在在每日工作开始或结束时候使用 =punching in= 以及 =punching out= 来启动计时。当我上班时候
我会执行punching in开始计时， 当吃午饭时执行punching out停止计时，吃完饭再punching in重新计时，
最后punching out 结束今日工作。 这样punching in以及punching out之间的每一分钟都被org记录下来。

开始pounching in时，会对预定义的默认任务会启动计时，直到手动关闭计时。我发现默认的org-mode设置，
会使我在每天工作中一些时间没法记录下来(如果没有默认任务来收集关闭计时以及开始计时这段时间的话)，
这儿一分钟，那儿一分钟，然后丢失的时间就被积累越来越多。比方说当你写个备忘时候，并且快速完成任务-这种
情况下时钟会被关闭。而好的备忘任务创建往往就是一分钟内完成，那么这个时间就没法收集起来。

我的计时设置工作方式如下：

- Punch in(开始计时)
  - 通过 =org-id= 预定义一个任务，punch in时，对预定义任务计时，直到时钟结束
- 任务计时， 当任务进入DONE状态时候，停止计时
  - 当任务完成后，自动停止计时，并且移到上层任务开始计时，或者回退到预定义的那个默认任务计时。
- 对其他需要工作任务计时
- punch out（停止计时）

我每天会重复对默认任务计时很多遍，但是由于现在实现了任务完成后，自动计时父任务，不需要这么来做了(因为
会自动给父任务计时). 所以我只有在punch in时候对默认任务启动一次计时。

当我 punch-in是指定一个 =Project X= 项目的一个任务，那么这个任务就变成默认任务，所有计时都会
记在该项目上直到我 punch out或者punch in其他任务。

我的org文件看上去如下：

=todo.org=:
#+begin_src org :exports src
,#+FILETAGS: PERSONAL
...
,* Tasks
,** Organization
   :PROPERTIES:
   :CLOCK_MODELINE_TOTAL: today
   :ID:       eb155a82-92b2-4f25-a3c6-0304591af2f9
   :END:
   ...
#+end_src

当我正在做某个任务时候，只要对该任务开始计时。当停止时，计时会自动向上移动，对带有todo
关键字的父任务(如果有）开始计时,这样可以让计时器一直工作在该项目中，保证一直对项目计时。
如果没有一个在todo状态的父任务，那么计时器就会回到默认任务上，对默认任务计时，直到我punch out
或者手动对其他任务计时。当有突发任务发生，我会启动capture，捕获该任务，对突发任务计时，
直到执行C-c C-c关闭捕获任务。

这个功能对我来说非常好。

例如，考虑到一下的org文件：

#+begin_src org :exports src
,* TODO Project A
,** NEXT TASK 1
,** TODO TASK 2
,** TODO TASK 3
,* Tasks
,** TODO Some miscellaneous task
#+end_src

我会按照如下顺序处理该文件中的任务：

1. 我通过快捷键 =F9-I= 开始一天工作并punch in默认任务
   执行完成后会对 =todo.org= 文件中 =Organization= 中的带有默认id的任务开始计时。
2. =F12-SPC= 来查看agenda视图
   选择'TODO Some miscellaneous task' 做为下个任务，通过快捷键 =I= 开始计时，计时器
   就会在该任务上。
3. 当完成该任务，通过快捷键 =C-c C-t d= 标记任务为完成状态。
   当完成该任务后，计时器会重新移回 =Organization= (默认)任务上上
4. 当我要做 =Project A= 任务，对 =Task 1= 计时
   当完成 =Task 1= 后，将任务标记为 =DONE=. 将会停止 =Task 1= 计时，计时器重新移到
   =Project A= 。当需要做 =Task 2= 时，对它计时即可。

我在项目 =Project A= 以及子任务上花的总时间将会记录在 =Project A= 上。当我将
=Project A= 完成。计时器将会重新移动到默认的任务上。

** 计时设置
:PROPERTIES:
:CUSTOM_ID: ClockSetup
:END:

开始时，我们需要找到哪个任务默认启动计时，保证任务能持续运行。可以简单通过快捷键
=F9 I= 快速完成。你可以在任何地方执行。计时停止时，会将计时器移动到父任务上(如果有todo关键字)
，如果没有的话，移动到默认任务上。

当子任务标记 =DONE= 计时器依然工作这样可以保证这个项目计时一直进行。我可以从项目中选择下个任务
并且计时，这样也不会丢失时间。

我将计时信息，状态转换信息以及其他信息都记录在任务的 =:LOGBOOK:= 中。

我的org mode计时相关设置如下:

#+header: :tangle yes
#+begin_src emacs-lisp
;;
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)
;;
;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Change tasks to NEXT when clocking in
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
;; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)
;; Enable auto clock resolution for finding open clocks
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)

(setq bh/keep-clock-running nil)

(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (bh/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (bh/is-project-p))
      "TODO"))))

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task.  If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
      ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
#+end_src

我曾经通过如下函数根据任务ID来对默认任务计时，但是现在，通过punch in以及punch out这种方式后，
我不需要这样来对默认任务计时了。通过 =F9 SPC= 调用 =bh/clock-in-last-task= 会将计时切回原来任务。

#+header: :tangle yes
#+begin_src emacs-lisp
(require 'org-id)
(defun bh/clock-in-task-by-id (id)
  "Clock in a task by id"
  (org-with-point-at (org-id-find id 'marker)
    (org-clock-in nil)))

(defun bh/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
Skip the default task and get the next one.
A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))
#+end_src

** 开始计时
:PROPERTIES:
:CUSTOM_ID: ClockingIn
:END:

当我开始以及继续一个任务时候，我会通过如下一种方式开始计时：

    - =C-c C-x C-i=
    - =I= 在agenda中想对任务计时
    - =I= 标题行第一个字符的加速键(加速键含义后面会介绍）
    - =f9 I= 当在agenda中对任务计时。
    - =f9 I= 当在org文件的一个任务上时，想对它计时

*** 设置默认计时任务
:PROPERTIES:
:CUSTOM_ID: ClockingInDefaultTask
:END:

我有个默认的 =** Organization= 任务在我的todo.org文件中，我将零散时间
统统记录在该任务中。这个是我每天开始工作通过 =F9 I= 计时第一个任务. 当重新组织
我的org文件，读取邮件，清理我的收件箱，或者做一些非项目相关的计划工作时，我
也会对默认任务计时。当在其他地方执行punch in时，都是对这个默认任务计时的。

如果我想修改默认计时任务，我只要访问在任意org buffer中的任务，通过=C-u C-u C-c C-x
C-i= 来对它计时。这样新的任务将会用来记录零散时间。

也可以通过快捷键 =C-u C-c C-x C-i d= 来快速对默认任务计时。另一种方式是对项目
中任务重复执行停止计时，那么计时器也会像父任务上移动，直到完成最上层任务，那么
计时器又会回到默认任务上计时。

*** 使用时钟历史来对老的任务重新计时
:PROPERTIES:
:CUSTOM_ID: ClockingInByClockHistory
:END:

可以使用计时历史来对该任务重启计时或者直接跳转到计时过的老的任务上。我通常使用该功能对
中断的任务重新计时。

考虑到如下的场景：

- 你开始工作，并对 =Task A= 计时 (比如默认任务)
- 现在你被新来的任务打断，需要切换到 =Task B= 任务(比如编写我如何使用org-mode)
- 完成 =Task B= (完成编写我如何使用org-mode任务)
- 你想回到 =Task A= （默认任务）继续工作。

这很容易做到。

1. 对任务 =Task A= 进行计时，继续工作
2. 进行任务 =Task B= (或者新建任务）并计时
3. 完成任务 =Task B= 后，执行快捷键 =C-u C-c C-x C-i i=

计时历史显示窗口就会显示出来，可以通过快捷键 =[i]= 来选择。
*C-u C-c C-x C-i 命令执行后的时钟历史选择窗口如下*
#+begin_example
Default Task
[d] norang          Organization                          <-- Task B
The task interrupted by starting the last one
[i] norang          Organization                          <-- Task B
Current Clocking Task
[c] org             NEXT Document my use of org-mode      <-- Task A
Recent Tasks
[1] org             NEXT Document my use of org-mode      <-- Task A
[2] norang          Organization                          <-- Task B
...
[Z] org             DONE Fix default section links        <-- 35 clock task entries ago
#+end_example

** 对所有任务计时 - 创建新任务时开始计时
:PROPERTIES:
:CUSTOM_ID: ClockEverythingWithNewTasks
:END:

如果想对所有任务计时那么你需要将任何事情抽象成任务。对于计划项目来说这没问题，突发
事情无时无刻不发生，所以你得有个地方记录处理中断花的时间。

为了处理这种情况，我创建了capture 任务，来记录突发任务。下面是对这种任务处理流程:

- 你正在处理计时任务时突发事件发生
- 通过快捷键 =C-c cj= 创建快速capture任务。
- 写好任务标题
- 去做该任务(吃午饭，谁便什么事情)
- 重定向 =C-c C-c=, 计时器将会回复到之前的任务上
- 对其他任务计时或者继续当前任务。

这意味着你不需要知道任务的一些细节，比如任务在什么文件，具体在文件中哪个位置，只是继续完成这个事情。
之后，当方便时，批量重定向组中的任务可以节省很多时间。

如果是一个不感兴趣的任务(像是coffee break) 我创建一个journal entry捕获，并且重定向到diary.org时间
树中。如果这个是一个需要跟踪并标记完成的任务，并且需要应用到某个项目中，我将创建捕获任务并且重定向到
合适的项目，而不是存到refile.org.

** 查找计时任务
:PROPERTIES:
:CUSTOM_ID: FindTasksToClockIn
:END:

为了找到之前的计时任务，可以通过如下方式(经常用的放在最前边)：

- 通过计时历史来查看 C-u C-c C-x C-i
  找到之前还没有完成的计时任务
- 从今日的agenda视图中选择任务
  =SCHEDULED= 以及 =DEADLINE= 任务优先级最高
- 从agenda视图中选择在 =NEXT= 状态任务
  完成这些任务,并标记任务状态为 =DONE=
- 从其他任务列表选择任务执行
- 使用agenda视图的过滤功能来选择继续工作的任务

对你所选择的任务punching in会限制agenda视图只显示这个项目相关任务，因此就可以一段时间聚焦在这件任务上。

** 编辑计时项
:PROPERTIES:
:CUSTOM_ID: EditingClockEntries
:END:

有时候为使得计时项更加能够反应真时耗时情况，需要编辑计时项。我发现我每周会编辑2-3个计时项。

有时候，由于我不在电脑旁边，我无法对该任务计时。这种情况，之前的任务依然在计时，但是我却
在做其他事情，这两个任务计时都会有问题。

我会记录下耗时情况，等我回来，我会对正确的任务计时，并且编辑计时开始结束时间，来纠正
错误计时。

为了快速找到计时项，可以使用agenda的日志模式。 =F12 a l= 显示今天的时间线。我使用该
功能快速定位时间线。F11可以到当前的计时任务，但是agenda日志模式更好，可以更快速找到并访问
老的计时项。

使用 =F12 a l= 打开agenda的日志模式，并且只显示计时时间。移动光标到需要编辑的计时线然后执行 =TAB=
然后你就会跳转到需编辑任务了。

为了编辑计时项，需要先将光标移动到编辑时间部分(使用键盘，不要使用鼠标-因为单击时间将会跳回到
agenda视图中)执行 =S-<up arrow>= 或者 =S-<down arrow>= 来改时间。

下面设置使得时间修改使用不连续的计时方法来改变(不会重复)

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-time-stamp-rounding-minutes (quote (1 1)))
#+end_src

通过shift 加方向箭头调整时间，也会同时调整总时间，非常方便。

我会经常查看任务是否有重叠当调整时间时候。agenda中有个新的视图来查看任务是否重叠
-- 只要在没人agenda视图中执行 = v c= , 这样计时偏移以及重叠计时就会显示出来。

我希望我的计时项尽可能准确。

通过下面脚本可以显示1分钟内的计时偏差。

#+begin_src emacs-lisp
(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
              :min-duration 0
              :max-gap 0
              :gap-ok-around ("4:00"))))
#+end_src

* 计时报告以及跟踪
:PROPERTIES:
:CUSTOM_ID: TimeReportingAndTracking
:END:

** 根据计时时间向客户收费
:PROPERTIES:
:CUSTOM_ID: BillingClientsForClockedTime
:END:

上月月初我通知客户工作完成，并要求支付。这就是根据我的计时数据修正费用的地方。

可以通过如下方式来达到计时收费的手段：

1. 验证计时数据完整有效
2. 用计时报告功能提炼出时间消耗报告
3. 创建基于计时信息的收费单

   当前收费单的创建我是通过外部一个软件包，这个软件包依赖org-mode计时信息。

4. 归档完成的任务，完成任务。

可以参看 [[#Archiving][归档]] 信息。

*** 验证计时数据完整有效
:PROPERTIES:
:CUSTOM_ID: VerifyingClockData
:END:

因为我经常修改任务(有时候一分钟修改不止一个)，但是修改任务很快就完成了，因此这种
情况下计时信息都是空的，所以我用下面设置删除那些空时间计时项。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
#+end_src

这个设置可以保证我的计时项干净-只保留那些对计时报告有帮助的计时项。

为检查未关闭的计时，我通过agenda视图的时钟检查( 在agenda中执行 =v c= ）。
通过agenda视图显示计时差异以及重叠。

为了看到上个月计时数据, 我使用 =F12 a v m b v c= 显示一整个月的视图，然后移动到上
个月，只显示计时信息。需要注意的是，为保证结果的准确性，需要移除所有agenda的限制以及
设置的过滤条件，这样就可以显示完全的任务以及计时信息，然后来检查差异以及重叠任务就会变
得准确。

在agenda中显示的任务计时情况方便检查任务是否有忘记关闭(没有关闭的任务，那么计时可能一直在
进行)。如果有任务项没有关闭，可以根据其他计时信息手工修改该任务计时信息。

*** 使用计时报告统计时间消耗
:PROPERTIES:
:CUSTOM_ID: ClockReports
:END:

向客户可计费时间信息保留在单独的org文件。

为获得 =XYZ.org= 所有任务花的时间的报告，你只需要打开 =XYZ.org= 文件，运行agenda
通过快捷键 =F12 <a v m b R>= 就能生成时间报告，从而能够查看上个月的任务计时信息.
这样就能通过agenda只显示该文件的信息，显示整个月的信息，然后可以移动到上月，生成计
上个月计时报告。

我的agenda计时报告显示5级细节并显示任务链接。我喜欢报告中生成详细的计时信息而不是精简的
，因此我通过如下设置重写了=:narrow= 值。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))
#+end_src

我曾经会对每个项目自动生成计时报告，然后在每个计费周期截止日手工修正计时信息。
我以计时信息为基础，跟客户讨论项目收费。但是我发现当有好几个文件需要自动
生成并手工更新时，非常令人乏味。

当生成计时报告功能引入后，我开始使用agenda计时报告功能。我发现这种方式更加
方便。agenda计时报告生成的是通用格式的数据而并不是假设的某种场景下的那种格式,
这样更加通用，因此我觉得使用这种方法已经足够用了。

** 任务评估以及列视图
:PROPERTIES:
:CUSTOM_ID: TaskEstimates
:END:

对于管理者来说评估一个任务得花多长时间是非常困难的。org-mode让评估变得简单了，
(基于历史任务实际计时情况)，然后只要对任务实际计时直到任务完成。

通过反复的评估任务大致使用时间以及实际使用时间，可以让你的评估能力变强。

*** 通过列模式评估新创建的任务
:PROPERTIES:
:CUSTOM_ID: CreatingTaskEstimates
:END:

我使用 =properties= 以及 =column view= 做项目评估。

我设置如下的列模式标题格式

#+header: :tangle yes
#+begin_src emacs-lisp
; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
#+end_src

通过这个设置可以在列模式中显示评估时间以及实际时间，方便项目耗时评估。

=Effort= 属性来记录任务完成评估时间。下面是我通常用的评估时间:

- 10 分钟
- 30 分钟
- 1 小时
- 2 小时
- 3 小时
- 4 小时
- 5 小时
- 6 小时
- 7 小时
- 8 小时

这些时间被存储在 =column mode= 全局属性 =Effort ALL= 中。

#+header: :tangle yes
#+begin_src emacs-lisp
; global Effort estimate values
; global STYLE property values for completion
(setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                    ("STYLE_ALL" . "habit"))))

通过快捷键 =C-c C-x C-c= 启动列模式来设置任务评估时间以及子任务评估时间，通过快捷键 =c= 折叠列模式. 它将在标题上创建一个以任务
名称命名的表格，评估时间以及实际时间会显示在表格中。

光标移动到 =Effort= 列，你可以容易评估值，通过快捷键 =q= 退出 =colume mode=.

*** 保存评估
:PROPERTIES:
:CUSTOM_ID: SavingEstimate
:END:

对于固定价格的任务，当你提供评估给客户后，然后开始着手完成项目，保存最开始评估数据是
很有必要的。

通过在你评估项目子树上创建动态计时报告以保留原来评估数据。 然后通过快捷键 =C-c C-x i RET=
生成新的计时表中包含评估时间以及实际计时时间。

#+begin_src org :exports src
Original Estimate
,#+BEGIN: columnview :hlines 1 :id local
| Task                        | Estimated Effort | CLOCKSUM |
|-----------------------------+------------------+----------|
| ** TODO Project to estimate |             5:40 |          |
| *** TODO Step 1             |             0:10 |          |
| *** TODO Step 2             |             0:10 |          |
| *** TODO Step 3             |             5:10 |          |
| **** TODO Step 3.1          |             2:00 |          |
| **** TODO Step 3.2          |             3:00 |          |
| **** TODO Step 3.3          |             0:10 |          |
| *** TODO Step 4             |             0:10 |          |
,#+END:
#+end_src



我通常会删除 =#+BEGIN:= 以及 =#+END:= 标记,以防止当将数据提供给客户后，在开始行执行=C-c C-c=
导致表格意外更新。

保留原始的评估数据，方便后续根据评估数据重新提炼项目任务合理分割子任务。

*** 检查你的评估
:PROPERTIES:
:CUSTOM_ID: ReviewingEstimates
:END:

=Column view= 非常方便用来检查评估。在该视图中会显示你对该项目的评估时间以及项目实际计时时间。

可以通过快捷键 =C-c C-x i RET= 创建一个动态计时表格, 这样就可以保留你的检查结果，同时也方便
给其他应用使用。

另外快捷键 =C-c C-x C-d= 也可以快速显示当前org文件的计时统计。

** 提供进度报告
:PROPERTIES:
:CUSTOM_ID: ProgressReporting
:END:

当有人需要知道现在进度报告，我通常在agenda视图快速生成一个日志报告，其中包含完成的
任务以及状态变化还有计时信息等。

下面设置可以在agenda中显示关闭的任务以及状态变化。 将其绑定到agenda计时报告('R')我
能够快速生成所有需要的细节。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed state)))
#+end_src

为生成报告，我先将agenda调整到合适的时间段中(今天，昨天，这周或者上周)然后执行快捷键
=l R= 在agenda视图最后生成报告(不包含计时数据）。

然后就是简单的将该报告格式化成合适的格式化提供给客户. 使用命令 =C-x C-w /tmp/agenda.html RET=
导出到HTML格式， 使用命令 =C-x C-w /tmp/agenda.txt RET= 导出成文本文件。当然也可以导出其他格式，
我通常是导出这两种格式。

通过标签过滤以及 =C-u R= 能够只生成相应标签的任务提供给客户。

* 标签
:PROPERTIES:
:CUSTOM_ID: Tags
:END:

每个任务可以有任意数量的标签。标签用途如下:

- 过滤任务
- 提供任务上下文
- 标记notes
- 标记电话回话
- 标记会议
- 标记任务需要重定向
- 标记任务在等待状态
- 标记任务被取消
- 在导出时候，阻止某些子任务被导出

我在agenda中经常用标签来过滤任务。这意味着可以通过指定的标签快速地在浩如烟海的
org文档中找到你想要的任务。

有些标签相互排斥。被定义在一个组中的标签，在一个任务中只能同时使用一个（抛开标签继承情况）。
这种标签通常是用在需要标记任务上下文的场景中(工作任务会标记 =@office=, 需要在办公室处理，
农场任务标记 =@farm=  表示需要在农场完成--我无法给拖拉机加油如果我不在农场。。。当然，
如果我在办公室中时，我会在agenda视图中过滤掉 =@farm= 相关任务，只显示带 =@office= 标签任务）

在同一个org文件中的任务，当需要加统一标签时，可以在文件头部使用 =#+FILETAGS:= 属性来定义，
当文件头部使用了这个属性，意味着所有的文件中的任务都具该标签。比如，我的norang.org文件
头部会使用该属性来创建一个NORANG标签(意味着文件中所有任务都具有该标签)，因此，我可以在agenda
视图中使用该标签过滤，使其只显示该文件中的任务。

** 标签
:PROPERTIES:
:CUSTOM_ID: OrgTagAlist
:END:

下面是我在agenda视图中定义的标签以及相对应的过滤的快捷键。

startgroup - endgroup（ =@xxx= ）里边定义的标签具有相互排斥关系-当应用其中一个标签时，
会移除该组其他标签，这种标签可以称作情景类标签-正如你无法同时出现在一个地方，所以如果有
个任务既被标记@farm又被标记@office，这很明显是不合符常理的，因此当你对一个已经标记@farm
的任务应用@office标签，那么@farm标签就会被自动移除。

另一类标签，例如 =WAITING= .. =FLAGGED= 之间定义的标签，它们并不互斥，对于任意
一个任务可以添加多个这种标签。有些标签是任务创建时候自动创建的。其中的过滤快捷键，方便
在agenda视图通过它过滤处相应的标签任务。当需要对任务设置标签时，可以使用快捷键 =C-c C-q=,
快速给任务添加删除标签，由于有标签的加持，所以在agenda视图中非常方便过滤任务。

我同时定义了 =FARM= 标签以及 =@farm= 标签。 =FARM= 用来设置文件属性 =FILETAGS= ，有了这个
标签，可以快速过滤文件中的任务。 =@farm= 表明任务需要 /在农场完成/。如果一个回电任务标记上
=FARM= 标签，我在家中吃午饭的时候就可以完成回电，因此并不需要我人在农场。
这就是为什么要用两个标签的原因。

#+header: :tangle yes
#+begin_src emacs-lisp
; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
                            ("@errand" . ?e)
                            ("@office" . ?o)
                            ("@home" . ?H)
                            ("@farm" . ?f)
                            (:endgroup)
                            ("WAITING" . ?w)
                            ("HOLD" . ?h)
                            ("PERSONAL" . ?P)
                            ("WORK" . ?W)
                            ("FARM" . ?F)
                            ("ORG" . ?O)
                            ("NORANG" . ?N)
                            ("crypt" . ?E)
                            ("NOTE" . ?n)
                            ("CANCELLED" . ?c)
                            ("FLAGGED" . ??))))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src

** 文件标签
:PROPERTIES:
:CUSTOM_ID: FileTags
:END:

文件标签用来快速对文件中所有任务应用统一标签的方法。

文件标签看上去像下面这样：

#+begin_src org :exports src
#+FILETAGS: NORANG @office
#+end_src

下表是我的不同org-mode文件中所使用的文件标签 =#+FILETAGS:= 。

*** 工作无关的org-mode 文件
:PROPERTIES:
:CUSTOM_ID: TaggingNonWorkFiles
:END:

| 文件         | 标签                  |
|--------------+-----------------------|
| todo.org     | PERSONAL              |
| gsoc2009.org | GSOC PERSONAL         |
| git.org      | GIT WORK              |
| org.org      | ORG WORK              |
| mark.org     | MARK PERSONAL         |
| farm.org     | FARM PERSONAL         |

*** 工作相关org-mode文件
:PROPERTIES:
:CUSTOM_ID: TaggingWorkFiles
:END:

| 文件        | 标签            |
|-------------+-----------------|
| norang.org  | NORANG @office  |
| ABC.org     | ABC @office     |
| XYZ.org     | XYZ @office     |
| ABC-DEF.org | ABC DEF @office |
| ABC-KKK.org | ABC KKK @office |
| YYY.org     | YYY @office     |

*** 重定向任务
:PROPERTIES:
:CUSTOM_ID: RefileTasks
:END:

| 文件       | 标签         |
|------------+--------------|
| refile.org | REFILE       |
|------------+--------------|

** 状态触发的添加的标签
:PROPERTIES:
:CUSTOM_ID: StateTriggerTags
:END:

下面标签在状态转换时候自动添加，状态转换的详细信息可以参考[[##ToDoStateTriggers][TODO状态触发]]

- =WAITING=
- =CANCELLED=

* 处理备忘
:PROPERTIES:
:CUSTOM_ID: HandlingNotes
:END:

备忘通常用来记录获取到的知识精华。它们很像任务，但是不需要完成(除了需要学习或者记忆那类).
不幸的是，生活中会记录大量备忘，那么就有太多的知识精华要记，想想那么多的需要记下来，我的脑袋就爆炸了。

org-mode 来解救这种尴尬。

通常我在Gnus中读取git邮件列表时，当我发现有些非常棒的功能或者事情我需要记住时，我就会
使用备忘。当需要创建备忘时，我会用备忘捕获模板=C-c c n= 来创建备忘，输入备忘大纲，
然后 =C-c C-c= 保存下来。剩下来要做的就是重定向（将来）到合适的项目文件中。

我有个agenda视图专门来找备忘。一般，我会将备忘重定向到相关的项目或者任务中。如果没有合适项目
重定向，我会将它重定向到 =* Notes= 中。我会为每个项目文件中添加像这样的备忘任务标题。
备忘在创建时候都会自动标记 =NOTE=  标签，一般在capture这个备忘时就已经默认添加了。
所以我也不需要额外再为它添加该标签，我只需要将它重定向到合适地方存储即可。只要
这个备忘在我的agenda管理的项目文件中(例如 在 org-agenda-files变量中的
文件)，那么我就会很容易找到这个备忘，只要在备忘agenda视图，通过快捷键 =F12 N= 就可以快速找到.
我也仅仅使用备忘agenda视图中的默认的过滤标签的过滤功能，来达到该目的。

通常给备忘加个有意义的标题是非常有必要的，能够方便回想技术细节而不需要从浩如烟海的
备忘中先找到它，然后展开备忘细节，再通过细节来了解详情。如果有个有意义标题的话，
只需要通过 =F12 N= 就可以。

对于项目相关的备忘，由于不是特别通用，可以在项目结束时候跟随项目归档，然后从agenda视图中
移除。

我的所有org备忘都在org.org文件中，我的git备忘在git.org中，这两个文件中都会有个 =* Notes=
标题。只要需要，我就能够快速找到他们。对于工作以及项目相关的备忘，我将把他们重定向到合适的项
目下面，并存储到项目相关的org文档中，当项目完成归档后，就会从agenda视图移除。

* 处理来电
:PROPERTIES:
:CUSTOM_ID: HandlinePhoneCalls
:END:

来电也是一种典型的中断的事件，我通常也是使用capture模板来创建(和所有的
中断事件一样)。对于来电任务，大部分工作都是通过capture模版完成的。我使用特
殊的capture模板来处理来电，并定制化一个函数从 =bbdb= 地址薄数据库中获取
用户信息来更新来电任务。

=C-c c p= 启动capture任务来捕获来电, 我也可以直接在模板中写备忘。光标在模板开始地方可以
插入来电人是谁。我可以使用 =bbdb= 查找函数，通过 =f9-p= 插入名称或者插入任何我想
插入的信息。 如果 =bbdb= 项需要创建，我可以这么做，并且用 =f9-p= 在任何时间来代替
来电者信息。我发现当这个人如果查不到，自动调用bbdb查看函数会打断我的工作流。有时候
我希望先记下备忘，然后在来电处理完成后补齐来电者信息。

通过capture来电模板创建来电任务后，该任务就开始计时，我同时也可以在通话中或者通话后
在bbdb里查找并替换来电人信息。来电任务创建后会设置 =:clock-in t= 属性，这样来电
任务就会在创建后，自动启动计时。

当电话完成后，我就执行快捷键 =C-c C-c= 关闭capture缓冲区停止计时。如果我
需要提前关闭来电任务捕获缓冲区，然后去查询一些信息，我只需要执行 =C-c C-c F9-SPC=
关闭capture 缓冲区(同时会停止计时）然后切换计时器到上一个计时任务，当查询任务完成，
计时器又会回到电话任务上继续计时。当回电完成，关闭电话任务计时器，默认任务又会
重新启动计时器进行计时(这样计时信息也不会丢失).

下面是capture中电话模板相关的定制化脚本，之后是一些电话相关查询函数。

#+header: :tangle no
#+begin_src emacs-lisp
;; Capture templates for: TODO tasks, Notes, appointments, phone calls, and org-protocol
(setq org-capture-templates
      (quote (...
              ("p" "Phone call" entry (file "~/git/org/refile.org")
               "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
              ...)))
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp
(require 'bbdb)
(require 'bbdb-com)

(global-set-key (kbd "<f9> p") 'bh/phone-call)

;;
;; Phone capture template handling with BBDB lookup
;; Adapted from code by Gregory J. Grubbs
(defun bh/phone-call ()
  "Return name and company info for caller from bbdb lookup"
  (interactive)
  (let* (name rec caller)
    (setq name (completing-read "Who is calling? "
                                (bbdb-hashtable)
                                'bbdb-completion-predicate
                                'confirm))
    (when (> (length name) 0)
      ; Something was supplied - look it up in bbdb
      (setq rec
            (or (first
                 (or (bbdb-search (bbdb-records) name nil nil)
                     (bbdb-search (bbdb-records) nil name nil)))
                name)))

    ; Build the bbdb link if we have a bbdb record, otherwise just return the name
    (setq caller (cond ((and rec (vectorp rec))
                        (let ((name (bbdb-record-name rec))
                              (company (bbdb-record-company rec)))
                          (concat "[[bbdb:"
                                  name "]["
                                  name "]]"
                                  (when company
                                    (concat " - " company)))))
                       (rec)
                       (t "NameOfCaller")))
    (insert caller)))  
#+end_src

* GTD 相关
:PROPERTIES:
:CUSTOM_ID: GTD
:END:

我每天都是截止日期/计划任务驱动的。

每天，第一件事，我会打开agenda视图然后从中选择合适任务来处理，详情参看[[#WhatDoIWorkOnNext][What do I work on next?]]

** 每周审查流程
:PROPERTIES:
:CUSTOM_ID: GTDWeeklyReview
:END:

每周第一天(通常周一)我会完成每周审查。
我会像这样保留一个列表来提醒我哪些需要完成。

为保证agenda够快，我设置如下参数
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-span 'day)
#+end_src

因此默认只有今天的任务才会显示出来。只有每周评审时候我才需要周视图，这使得我的agenda
生成的非常快。

我有个重复任务，可以保证我的每周评审方便处理。每周一会弹出提醒。但是这周评审
是周二完成的因为周一放假。

#+begin_src org :exports src
,* NEXT Weekly Review [0/6]
  SCHEDULED: <2009-05-18 Mon ++1w> 
  :LOGBOOK:...
  :PROPERTIES:...

  What to review:

   - [ ] Check follow-up folder
   - [ ] Review weekly agenda =F12 a w //=
   - [ ] Check clocking data for past week =v c=
   - [ ] Review clock report for past week =R=
     - Check where we spent time (too much or too little) and rectify this week
   - [ ] Look at entire agenda for today  =F12 SPC=
   - [ ] Review projects =F12 SPC //= and =V= repeatedly to view each project

   - start work
     - daily agenda first - knock off items
     - then work on NEXT tasks
#+end_src

第一个[]条目用来跟踪文件夹，这项任务使得我能从浩如烟海的纸质文档抽出身来-那些我
需要处理但是不是特别紧急的任务。例如收到的大量邮件情况，我暂时不想要处理。
我只要将它们放入我的 =Follow-up= 文件夹接下来就可以不用管了，直到每周评审时。

我会过一遍这个文件夹中任务，选出那些需要处理的任务。之后这些任务将会移到 =org-mode=
文件中。我会对任务设置计划，这样任务后续就会显示到agenda视图中，接下来只要根据
agenda任务列表来处理任务即可。

这个流程非常适合我，对于其他人可能需要调整。

** 项目定义以及找出无法推进的项目
:PROPERTIES:
:CUSTOM_ID: Projects
:END:

我使用一个简单的项目定义来标记任务为一个项目。这不需要额外花经历处理。任何任务
只要有个带todo关键字的子任务，那么这个任务就是项目。

项目中如果没有任意子任务包含 =NEXT= 关键字，那么这个任务就是无法推进的项目。

org agenda中有单独视图来显示无法推进项目列表。当有受阻项目显示在我的agenda视图
我会将其设置为 =NEXT= 任务，这样就会保证无法推进列表是空的。同时可以保证项目
继续进行。

我通过如下设置禁用org-mode无法推进项目的agenda视图。
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-stuck-projects (quote ("" nil nil "")))
#+end_src

这可以避免org-mode显示我通过 =F12 #= 显示的项目。我的定制化受阻项目视图
是我的agenda视图的一部分，可以通过 =F12 SPC= 来查看。

项目中有可能包含子项目-子项目也有可能无法推进。子项目无法推进时，也是显示在无法
推进项目列表中，因此我可以创建 =NEXT= 任务推进项目继续进行。

下面的例子中 =Stuck Project A= 是无法推进项目，因为它子任务都不在 =NEXT= 状态。

=Project C= 却不是，因为它包含 =NEXT= 状态任务 =SubTask G= 以及 = Task I= .
=Stuck Sub Project D= 也是无法推进项目，因为 =SubTask E= 并没有 =NEXT= 状态
也没有其他可以处理的任务。

#+begin_src org :exports src
,* Category
,** TODO Stuck Project A
,*** TODO Task B
,** TODO Project C
,*** TODO Stuck Sub Project D
,**** TODO SubTask E
,*** TODO Sub Project F
,**** NEXT SubTask G
,**** TODO SubTask H
,*** NEXT Task I
,*** TODO Task J
#+end_src

所有的无法推进项目以及子项目将会一直显示在无法推进列表，直到新建或者修改既有任务
状态到 =NEXT= 。 如果项目有任务处在 =WAITING= 状态，等待某些条件得到
满足。 这种情况，我会将他们一直保持在无法推进项目列表，去做其他事情，待到等待条件满足
就可以将项目从无法推进项目列表移除。无法推进项目会非常醒目，能够及时提醒我，
当我查看agenda 视图时，看到有无法推进项目，我就会一直跟踪等待任务是否完成。

下面是一些辅助函数来帮我判定任务是否是项目并用在agenda视图中。

#+header: :tangle yes
#+begin_src emacs-lisp
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
                   nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))

(defun bh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defun bh/toggle-next-task-display ()
  (interactive)
  (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

(defun bh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-non-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-task-p)
        nil)
       (t
        next-headline)))))

(defun bh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags-at)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (bh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (bh/is-subproject-p)
        nil
      next-headline)))
#+end_src

* 归档
:PROPERTIES:
:CUSTOM_ID: Archiving
:END:

** 归档子树
:PROPERTIES:
:CUSTOM_ID: ArchivingSubtrees
:END:

我更新了原来的归档流程。曾经我会将整个子树移动到该项目的，另外一个使用的归档文件中。
在agenda视图中，可以通过通过快捷键 =a y= 将 =FILE.org= 任务子树归档到 =FILE.org_archive= 文件中。

我还是会像以前一样将任务归档到原来那个归档文件中，现在我只会对那些已经完成并且非常
老的任务才会做归档。我会在agenda视图最后部分列出需要归档的任务，这些任务意味着
我已经花了很多时间在上面。归档历史任务可以让我的任务子树变得更整洁，并且能够移除
我已经不感兴趣的任务。在归档过程中会在任务上添加额外的属性数据表示该数据从何处
归档而来，有助于在复原时候方便回退到原处。

我的归档文件比较大，但是到现在为止，我没有发现需要根据年份来将归档文件分割多个文件的必要。

在上节的agenda视图中在新的月份开始时，我们可以看到一些需要归档的任务。那些已经完成的
并且没有任何本月或者上月时间戳的任务（例如已经超过30天的任务）就可以归档。时间戳包含
完成日期，便签，计时数据等-任何活跃以及不活跃的时间戳。

归档很简单，只要通过 =m= 标记所有要归档的项,然后通过 =B $= 将他们归档到合适的位置,
每月只需要花5分钟就可以完成归档了。

** 归档设置
:PROPERTIES:
:CUSTOM_ID: ArchiveSetup
:END:

我现在不用 =ARCHIVE= 属性来标记需要归档任务。能够归档任务到归档文件中
=Archived Tasks= 大纲下即可表示归档完成。

下列设置保证任务在归档后就不会显示在agenda中。这给归档未在完成状态的任务提供
了可能。默认情况下，任务被归档到归档文件 =* Archived Tasks= 中。

归档功能没法保证项目树完整。对于在done状态的比较老的任务，当对其归档后，它
就会从主的org文件中移除了。当然也可以从归档文件中，根据任务属性，将原来任务复原回来，
但是我从来不这么做。归档的属性还是非常有用的，每年我都会从归档数据中查看些任务，
除了这种情况外，归档的任务就只是用来做备份用。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-archive-mark-done nil)
(setq org-archive-location "%s_archive::* Archived Tasks")
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp
(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving"
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (if (member (org-get-todo-state) org-todo-keywords-1)
          (if (member (org-get-todo-state) org-done-keywords)
              (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                     (a-month-ago (* 60 60 24 (+ daynr 1)))
                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                     (this-month (format-time-string "%Y-%m-" (current-time)))
                     (subtree-is-current (save-excursion
                                           (forward-line 1)
                                           (and (< (point) subtree-end)
                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                (if subtree-is-current
                    subtree-end ; Has a date in this month or last month, skip it
                  nil))  ; available to archive
            (or subtree-end (point-max)))
        next-headline))))
#+end_src

** 归档标签 - 隐藏信息
:PROPERTIES:
:CUSTOM_ID: ArchiveTagHidesInfo
:END:

我只有在一种情况下，才会对归档任务打上ARCHIVE标签，那就是这个任务非常大，里边包含
非常多信息，这样的任务，我通常不想打开任务细节（以防止自己陷入浩如烟海的信息中）。
当然，我可以通过 C-TAB打开它，如果我不介意自己陷入这种境地（比如说任务下有一个巨大的数据表）。
通常情况下，我不希望显示这些信息(因此我会为它打上ARCHIVE标签)。

** 什么时候归档
:PROPERTIES:
:CUSTOM_ID: WhenToArchive
:END:

每月归档一次对我来说已经足够了。我会将完成的任务保留30天，同样，这能够保留最近30天计时信息。
这能保证我的agenda视图时间上连续（这个月，上个月，以及没完成的任务）(方便随时查看,历史任务完成信息)。
因为我很少访问归档任务(因此把要归档的先保留下来，待查看). 这样可以使得我减少从归档文件恢复任务的可能。

归档让我的记录任务的工作文件非常干净整洁。如果我真的需要去找归档的任务，我知道它一定就
在归档文件中某个位置。

* 发布导出章节
:PROPERTIES:
:CUSTOM_ID: Publishing
:END:

我平时不会对我任务做很多发布相关的操作，但是我保留了些敏感的客户系统信息。大部分都是通过备忘形式
记录并导出到HTML中。

当前 http://doc.norang.ca/ 网站所有网页都是通过我的org文件发布生成的。这包含网站的索引页面。

org-mode可以将文件发布为很多格式，包含（但不限于）

- ASCII
  (文本 - 并非org格式文件)
- HTML
- LaTeX
- Docbook
  这可以导出成大量其他格式，像 ODF，XML等
- PDF
  通过LaTex以及Docbook
- iCal

我没有花精力去研究org-mode布局功能（使得文档更美观）。对于发布，我主要使用发布场景
就是用org-mode创建些HTML文档，方便在线阅读。也许将来因为需要，我会研究下org布局
功能。

** 新的导出设置

新的导出功能由 Nicolas Goazious实现并在org 8.0版本中发布。

我的导出设置如下：

字母列表选项需要在导出设置被载入后才能正确工作。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-alphabetical-lists t)

;; Explicitly load required exporters
(require 'ox-html)
(require 'ox-latex)
(require 'ox-ascii)
#+end_src

*** 老的exporter转换成新的exporter

下面是我做的为兼容新的exporter功能的修改。

- exporters 显示依赖

  - 添加 =ox-html=

  - 添加 =ox-latex=

  - 添加 =ox-ascii=

- 重命名参数

  - =org-export-html-style-extra= 命名为 =org-html-head-extra=

  - =org-export-html-validation-link= 命名为 =org-html-validation-link=

  - =org-export-html-inline-images= 命名为 =org-html-inline-images=

  - =org-export-html-style-include-default= 命名为 =org-html-head-include-default-style=

  - =org-export-html-xml-declaration= 命名为 =org-html-xml-declaration=

  - =org-export-latex-listings= 命名为 =org-latex-listings=

  - =org-export-html-style-include-scripts= 命名为 =org-html-head-include-scripts=

- 发布修改

  - 重命名 =:publishing-function=

    - =org-publish-org-to-html= 命名为 =org-html-publish-to-html=

    - =org-publish-org-to-org= 命名为 =org-org-publish-to-org=

  -  =:style= 命名为 =:html-head=

- 修改 =bh/is-late-deadline= 来处理修改agenda中的截止字段

- 根据截止日期反转agenda列表

  负值将不会在agenda中显示

- 添加空行防止被导出。

** org-babel 设置
:PROPERTIES:
:CUSTOM_ID: OrgBabel
:END:

org-babel使得org文件通过使用外部插件，比如ditaa, graphviz, PlantUML等其他工具来生成各种图标。

设置非常简单。 =ditaa= 是跟随org-mode发布。对于其他插件，你需要在系统中安装 =graphviz= 以及
=PlantUML= 软件包。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-ditaa-jar-path "~/git/org-mode/contrib/scripts/ditaa.jar")
(setq org-plantuml-jar-path "~/java/plantuml.jar")

(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)

; Make babel results blocks lowercase
(setq org-babel-results-keyword "results")

(defun bh/display-inline-images ()
  (condition-case nil
      (org-display-inline-images)
    (error nil)))

(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
         (dot . t)
         (ditaa . t)
         (R . t)
         (python . t)
         (ruby . t)
         (gnuplot . t)
         (clojure . t)
         (sh . t)
         (ledger . t)
         (org . t)
         (plantuml . t)
         (latex . t))))

; Do not prompt to confirm evaluation
; This may be dangerous - make sure you understand the consequences
; of setting this -- see the docstring for details
(setq org-confirm-babel-evaluate nil)

; Use fundamental mode when editing plantuml blocks with C-c '
(add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))

#+end_src

然后你只需要创建一个 =begin-src= 块为合适的工具，编辑文件，通过快捷键 =C-c C-c=
生成图片。然后结构就会显示。你可以通过 =C-c C-x C-v= 来控制图像显示与否。

我禁止启动时候，在org文件加载图像因为当我通过ssh来登录远端打开org文件，如果默认显示图片就会有问题
（比如说我的android手机）在非X系统上没法显示图片。对我来说能够远程登录并查看org 文件
比远程查看图像更加重要。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Don't enable this because it breaks access to emacs from my Android phone
(setq org-startup-with-inline-images nil)
#+end_src

** 如何使用ditta
:PROPERTIES:
:CUSTOM_ID: playingwithditaa
:END:

[[http://ditaa.sourceforge.net/][ditaa]] 是一个能够快速将想法转换成图像的工具，
并且 =ditaa= 是跟着 org-mode一起发布的！本文档中的所有图片都是通过org-mode使用纯
文本方式自动生成的。

Artist模式方便使用ditaa创建方块以及连线。

ditaa在org-mode画图的源码像下面这样：

#+begin_src org :exports src
,#+begin_src ditaa :file some_filename.png :cmdline -r -s 0.8
  <context of ditaa source goes here>
,#+end_src
#+end_src

下面是没有 =#+begin_src= 以及 =#+end_src= 画出的图形的例子。

#+begin_src ditaa :file communication.png :cmdline -r -s 0.8 :exports both :cache yes
    +-----------+        +---------+  
    |    PLC    |        |         |                
    |  Network  +<------>+   PLC   +<---=---------+ 
    |    cRED   |        |  c707   |              | 
    +-----------+        +----+----+              | 
                              ^                   | 
                              |                   | 
                              |  +----------------|-----------------+
                              |  |                |                 |
                              v  v                v                 v
      +----------+       +----+--+--+      +-------+---+      +-----+-----+       Windows clients
      |          |       |          |      |           |      |           |      +----+      +----+
      | Database +<----->+  Shared  +<---->+ Executive +<-=-->+ Operator  +<---->|cYEL| . . .|cYEL|
      |   c707   |       |  Memory  |      |   c707    |      | Server    |      |    |      |    |
      +--+----+--+       |{d} cGRE  |      +------+----+      |   c707    |      +----+      +----+
         ^    ^          +----------+             ^           +-------+---+
         |    |                                   |                        
         |    +--------=--------------------------+                    
         v                                                             
+--------+--------+                                                         
|                 |                                                         
| Millwide System |            -------- Data ---------                      
| cBLU            |            --=----- Signals ---=--                      
+-----------------+                                                         
#+end_src

#+results[b72ce84b1be00db6721081a8353a0c879f187fdd]:
[[file:communication.png]]

** 使用graphviz
:PROPERTIES:
:CUSTOM_ID: Graphviz
:END:

[[http://www.graphviz.org/][Graphviz]] 是另一个伟大的方便在org文档画图的工具。

graphviz在org中画图源码看上去如下：

#+begin_src org :exports src
,#+begin_src dot :file some_filename.png :cmdline -Kdot -Tpng
  <context of graphviz source goes here>
,#+end_src
#+end_src

#+begin_src dot :file gv01.png :cmdline -Kdot -Tpng :exports both :cache yes
digraph G {
  size="8,6"
  ratio=expand
  edge [dir=both]
  plcnet [shape=box, label="PLC Network"]
  subgraph cluster_wrapline {
    label="Wrapline Control System"
    color=purple
    subgraph {
    rank=same
    exec
    sharedmem [style=filled, fillcolor=lightgrey, shape=box]
    }
    edge[style=dotted, dir=none]
    exec -> opserver
    exec -> db
    plc -> exec
    edge [style=line, dir=both]
    exec -> sharedmem
    sharedmem -> db
    plc -> sharedmem
    sharedmem -> opserver
  }
  plcnet -> plc [constraint=false]
  millwide [shape=box, label="Millwide System"]
  db -> millwide

  subgraph cluster_opclients {
    color=blue
    label="Operator Clients"
    rankdir=LR
    labelloc=b
    node[label=client]
    opserver -> client1
    opserver -> client2
    opserver -> client3
  }
}
#+end_src

#+results[296ce064f7aab7f79ba32a4e903ed7a31b01ca73]:
[[file:gv01.png]]

=-Kdot= 是可选的（默认是 =dot= ）但是你可以用其他graphviz来替换(例如 =twopi=, =neato=, =circo= 等)。

** 使用PlantUML
:PROPERTIES:
:CUSTOM_ID: PlantUML
:END:

我刚开始使用[[http://plantuml.sourceforge.net/][PlantUML]]，它是基于[[http://www.graphviz.org/][Graphviz]]创建的。
我现在仍在尝试使用它，到现在为止我太喜欢它了。本文中状态图都是通过PlantUML来画的。

PlantUML在org中绘图源码看上去如下：
#+begin_src org :exports src
,#+begin_src plantuml :file somefile.png
  <context of PlantUML source goes here>
,#+end_src
#+end_src

*** 时序图
:PROPERTIES:
:CUSTOM_ID: PlantUMLSequence
:END:

#+begin_src plantuml :file sequence.png :exports both :cache yes
title Example Sequence Diagram
activate Client
Client -> Server: Session Initiation
note right: Client requests new session
activate Server
Client <-- Server: Authorization Request
note left: Server requires authentication
Client -> Server: Authorization Response
note right: Client provides authentication details
Server --> Client: Session Token
note left: Session established
deactivate Server
Client -> Client: Saves token
deactivate Client
#+end_src

#+results[9b612e0e68cd747fc032d949b739f4c5b06dee21]:
[[file:sequence.png]]

*** 用例图
:PROPERTIES:
:CUSTOM_ID: PlantUMLUseCase
:END:

#+begin_src plantuml :file usecase.png :exports both :cache yes
LabUser --> (Runs Simulation)
LabUser --> (Analyses Results)
#+end_src

#+results[b7079ee21eb099b19ca524bf62e84edb7c317890]:
[[file:usecase.png]]

*** 对象图
:PROPERTIES:
:CUSTOM_ID: PlantUMLObject
:END:

#+begin_src plantuml :file object.png :exports both :cache yes
Object1 <|-- Object2
Object1: someVar
Object1: execute()
Object2: getState()
Object2: setState()
Object2: state
#+end_src

#+results[12eb2caa1043195361ca1953b474932e796e80f5]:
[[file:object.png]]

*** 状态图
:PROPERTIES:
:CUSTOM_ID: PlantUMLState
:END:

#+begin_src plantuml :file plantuml_example_states.png :exports both :cache yes
[*] --> Start
Start -> State2
State2 -> State3
note right of State3: Notes can be\nattached to states
State2 --> State4
State4 -> Finish
State3 --> Finish
Finish --> [*]
#+end_src

#+results[5faa6c28383266f9e8b76f4a8c70012f7ab70753]:
[[file:plantuml_example_states.png]]

** 发布单个文件
:PROPERTIES:
:CUSTOM_ID: PublishingSingleFiles
:END:

org-mode通过一个导出函数, 就可以将该文件导出成一个标准的格式的文件。导出函数一般绑定
到快捷键 =C-c C-e= ，之后跟着导出类型的快捷键就可以完成导出。

通过这种方式可以将单个文件以及文件的一部分导出--如果限制org-mode文件到文件的部分内容，
当导出的时候只会导出选择部分。

** 发布项目
:PROPERTIES:
:CUSTOM_ID: PublishingProjects
:END:

我使用publishing功能来导出多个文件或者项目。我不想记住导出文件生成的位置，
org-mode项目可以解决这个问题。

[[http://doc.norang.ca]] 这个网站（其他一些非公开的文件）都是通过org-mode文件
来创建，通过项目形式发布。象我这样，只配置一次，后面就不再注意这些细节的人这个功能
非常棒。我喜欢这种工作方式(tm).

当前，我有如下5个项目，通过org-mode发布：

- norang （网站）
- doc.norang.ca (网站，发布文档）
- doc.norang.ca/privat (网站，非公开完档）
- www.norang.ca/tmp (用测试org-mode来临时发布网站）
- org文件（其他网站使用的org文件）

如下是我的设置：

#+header: :tangle yes
#+begin_src emacs-lisp
; experimenting with docbook exports - not finished
(setq org-export-docbook-xsl-fo-proc-command "fop %s %s")
(setq org-export-docbook-xslt-proc-command "xsltproc --output %s /usr/share/xml/docbook/stylesheet/nwalsh/fo/docbook.xsl %s")
;
; Inline images in HTML instead of producting links to the image
(setq org-html-inline-images t)
; Do not use sub or superscripts - I currently don't need this functionality in my documents
(setq org-export-with-sub-superscripts nil)
; Use org.css from the norang website for export document stylesheets
(setq org-html-head-extra "<link rel=\"stylesheet\" href=\"http://doc.norang.ca/org.css\" type=\"text/css\" />")
(setq org-html-head-include-default-style nil)
; Do not generate internal css formatting for HTML exports
(setq org-export-htmlize-output-type (quote css))
; Export with LaTeX fragments
(setq org-export-with-LaTeX-fragments t)
; Increase default number of headings to export
(setq org-export-headline-levels 6)

; List of projects
; norang       - http://www.norang.ca/
; doc          - http://doc.norang.ca/
; org-mode-doc - http://doc.norang.ca/org-mode.html and associated files
; org          - miscellaneous todo lists for publishing
(setq org-publish-project-alist
      ;
      ; http://www.norang.ca/  (norang website)
      ; norang-org are the org-files that generate the content
      ; norang-extra are images and css files that need to be included
      ; norang is the top-level project that gets published
      (quote (("norang-org"
               :base-directory "~/git/www.norang.ca"
               :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs"
               :recursive t
               :table-of-contents nil
               :base-extension "org"
               :publishing-function org-html-publish-to-html
               :style-include-default nil
               :section-numbers nil
               :table-of-contents nil
               :html-head "<link rel=\"stylesheet\" href=\"norang.css\" type=\"text/css\" />"
               :author-info nil
               :creator-info nil)
              ("norang-extra"
               :base-directory "~/git/www.norang.ca/"
               :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs"
               :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
               :publishing-function org-publish-attachment
               :recursive t
               :author nil)
              ("norang"
               :components ("norang-org" "norang-extra"))
              ;
              ; http://doc.norang.ca/  (norang website)
              ; doc-org are the org-files that generate the content
              ; doc-extra are images and css files that need to be included
              ; doc is the top-level project that gets published
              ("doc-org"
               :base-directory "~/git/doc.norang.ca/"
               :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
               :recursive nil
               :section-numbers nil
               :table-of-contents nil
               :base-extension "org"
               :publishing-function (org-html-publish-to-html org-org-publish-to-org)
               :style-include-default nil
               :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
               :author-info nil
               :creator-info nil)
              ("doc-extra"
               :base-directory "~/git/doc.norang.ca/"
               :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
               :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
               :publishing-function org-publish-attachment
               :recursive nil
               :author nil)
              ("doc"
               :components ("doc-org" "doc-extra"))
              ("doc-private-org"
               :base-directory "~/git/doc.norang.ca/private"
               :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs/private"
               :recursive nil
               :section-numbers nil
               :table-of-contents nil
               :base-extension "org"
               :publishing-function (org-html-publish-to-html org-org-publish-to-org)
               :style-include-default nil
               :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
               :auto-sitemap t
               :sitemap-filename "index.html"
               :sitemap-title "Norang Private Documents"
               :sitemap-style "tree"
               :author-info nil
               :creator-info nil)
              ("doc-private-extra"
               :base-directory "~/git/doc.norang.ca/private"
               :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs/private"
               :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
               :publishing-function org-publish-attachment
               :recursive nil
               :author nil)
              ("doc-private"
               :components ("doc-private-org" "doc-private-extra"))
              ;
              ; Miscellaneous pages for other websites
              ; org are the org-files that generate the content
              ("org-org"
               :base-directory "~/git/org/"
               :publishing-directory "/ssh:www-data@www:~/org"
               :recursive t
               :section-numbers nil
               :table-of-contents nil
               :base-extension "org"
               :publishing-function org-html-publish-to-html
               :style-include-default nil
               :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
               :author-info nil
               :creator-info nil)
              ;
              ; http://doc.norang.ca/  (norang website)
              ; org-mode-doc-org this document
              ; org-mode-doc-extra are images and css files that need to be included
              ; org-mode-doc is the top-level project that gets published
              ; This uses the same target directory as the 'doc' project
              ("org-mode-doc-org"
               :base-directory "~/git/org-mode-doc/"
               :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
               :recursive t
               :section-numbers nil
               :table-of-contents nil
               :base-extension "org"
               :publishing-function (org-html-publish-to-html)
               :plain-source t
               :htmlized-source t
               :style-include-default nil
               :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
               :author-info nil
               :creator-info nil)
              ("org-mode-doc-extra"
               :base-directory "~/git/org-mode-doc/"
               :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
               :base-extension "css\\|pdf\\|png\\|jpg\\|gif\\|org"
               :publishing-function org-publish-attachment
               :recursive t
               :author nil)
              ("org-mode-doc"
               :components ("org-mode-doc-org" "org-mode-doc-extra"))
              ;
              ; http://doc.norang.ca/  (norang website)
              ; org-mode-doc-org this document
              ; org-mode-doc-extra are images and css files that need to be included
              ; org-mode-doc is the top-level project that gets published
              ; This uses the same target directory as the 'doc' project
              ("tmp-org"
               :base-directory "/tmp/publish/"
               :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs/tmp"
               :recursive t
               :section-numbers nil
               :table-of-contents nil
               :base-extension "org"
               :publishing-function (org-html-publish-to-html org-org-publish-to-org)
               :html-head "<link rel=\"stylesheet\" href=\"http://doc.norang.ca/org.css\" type=\"text/css\" />"
               :plain-source t
               :htmlized-source t
               :style-include-default nil
               :auto-sitemap t
               :sitemap-filename "index.html"
               :sitemap-title "Test Publishing Area"
               :sitemap-style "tree"
               :author-info t
               :creator-info t)
              ("tmp-extra"
               :base-directory "/tmp/publish/"
               :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs/tmp"
               :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
               :publishing-function org-publish-attachment
               :recursive t
               :author nil)
              ("tmp"
               :components ("tmp-org" "tmp-extra")))))

; I'm lazy and don't want to remember the name of the project to publish when I modify
; a file that is part of a project.  So this function saves the file, and publishes
; the project that includes this file
;
; It's bound to C-S-F12 so I just edit and hit C-S-F12 when I'm done and move on to the next thing
(defun bh/save-then-publish (&optional force)
  (interactive "P")
  (save-buffer)
  (org-save-all-org-buffers)
  (let ((org-html-head-extra)
        (org-html-validation-link "<a href=\"http://validator.w3.org/check?uri=referer\">Validate XHTML 1.0</a>"))
    (org-publish-current-project force)))

(global-set-key (kbd "C-s-<f12>") 'bh/save-then-publish)
#+end_src

主项目是 =norang= ， =doc= , =doc-private= , =org-mode-doc= 以及
=tmp= 。这些项目自动发布到web 服务器相应目录。当发布时候将会导出所有修改的
页面，生成图片以及拷贝相应的文件到web服务器中，因此方便立马查看。

网站 http://doc.norang.ca/ 包含所有客户私密文档（因此要配置访问权限）访问权
限通过Apache访问权限控制来实现。我不会从公共页面创建这些文档链接(用以访问它们)。
http://doc.norang.ca/someclient/ 会显示在路径 =~/git/doc.norang.ca/someclient/=
所有的org文件索引如果该网站被设置可视的话。我会使用这些网站上大部分信息，当然如果
我的客户对这些信息感兴趣，我也会给他们开权限查看。

这样很棒，我知道我的备忘在网站上，并且我可以访问他们。我也方便跟其他人分享
备忘，只要给他们相应的链接(并开通访问权限)即可。

我所要记的就是修改合适的org文件，然后通过C-S-F12发布--不是特别难:)

我有个临时的发布网站用来验证发布项目。这个就是 =tmp= 网站，它将 =/tmp/publish= 文件
拷贝过来，导出这些文件到发布路径。这方便在线测试一些新功能。

** 其他导出设置
:PROPERTIES:
:CUSTOM_ID: MiscBabelExportSettings
:END:

这些是我收集的关于导出和发布相关的设置脚本。

*** 加固源码 Latex lists
:PROPERTIES:
:CUSTOM_ID: FontifyLatexListings
:END:

当要导出为latex格式，我使用下列设置加固源码列表:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-latex-listings t)
#+end_src

*** 不带XML头导出HTML
:PROPERTIES:
:CUSTOM_ID: ExportHTMLWithoutXMLHeader
:END:

我使用下列设置移除HTML方式导出的文档中的xml头。如果不移除这些XML头，当通过open Office打开HTML将其转换成ODT。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-html-xml-declaration (quote (("html" . "")
                                       ("was-html" . "<?xml version=\"1.0\" encoding=\"%s\"?>")
                                       ("php" . "<?php echo \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\"; ?>"))))
#+end_src

*** 导出时允许绑定参数导出
:PROPERTIES:
:CUSTOM_ID: AllowVariableBindingForExport
:END:

下面设置允许设置 #+BIND: 这样在导出时候可以绑定一些参数，导出时候就不需要再次确认。
在极少情况下我会覆盖一些org-mode一些导出参数。这样在导出时候就不会弹出提示。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-export-allow-BIND t)
#+end_src

* 提醒
:PROPERTIES:
:CUSTOM_ID: Reminders
:END:

我使用appt来实现org-mode提醒功能。它简单而不唐突--将待处理的情况显示到状态栏并且每隔12,9,6,3以及
0分钟提示。

每次显示agenda视图时候（我会经常这么做）约定列表就会清除然后根据今天的情况重新创建。
这意味着每次当我打开agenda视图，当有任务被重新计划，或者新加新任务，或者删除任务提醒列表
都会自动更新。

** 提示设置
:PROPERTIES:
:CUSTOM_ID: ReminderSetup
:END:

#+header: :tangle yes
#+begin_src emacs-lisp
; Erase all reminders and rebuilt reminders for today from the agenda
(defun bh/org-agenda-to-appt ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

; This is at the end of my .emacs - so appointments are set up when Emacs starts
(bh/org-agenda-to-appt)

; Activate appointments so we get notifications
(appt-activate t)

; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'bh/org-agenda-to-appt)
#+end_src

* 提高生产力工具
:PROPERTIES:
:CUSTOM_ID: ProductivityTools
:NOBLOCKING: t
:END:

这章主要是一系列我的org-mode中使用的emacs定制化的集合。

** Abbrev-mode以及Skeletons
:PROPERTIES:
:CUSTOM_ID: AbbrevMode
:END:

我在Abbrev-mode中使用skeletons，可以快速在我的emacs缓冲区添加预定义代码块。

我需要创建如下一些代码块：

    - org-mode中的通用代码块
    - org-mode中的plantuml块
      - plantuml活动图的代码块
      - plantuml序列图的代码块
    - org-mode中graphviz dot代码块
    - ditta代码块
    - org-mode中elisp代码块

我用依然用 =< e TAB= 或者 =< s TAB= 创建用例代码块以及shell脚本代码块。

这是我当前org-mode关联的设置。每个相关代码块都定义一个abbrev-mode快捷键，
因此我可以输入 =splantuml RET= 来创建一个plantuml代码块。同时弹出文件名
来命名生成的图像。

工作中生成代码块的同时也会为其添加 =：tangle= 头，这样代码块中就可以包含
=@startuml= 以及 =@enduml= 。因此我可以使用tangle功能，生成新文件，并分享
给同事。这样，新文件就可以在notepad以及 =plantUML= jar单独运行。

我使用 =s= 快捷键阻止abbrev-mode生效，防止在一个句子中输入plantuml时候被当
做要插入 =PlantUML= 代码块。

为在活动视图中方便使用方便，我添加了 =sif= 以及 =sfor= 用来生成if判断以及for
循环。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Enable abbrev-mode
(add-hook 'org-mode-hook (lambda () (abbrev-mode 1)))

;; Skeletons
;;
;; sblk - Generic block #+begin_FOO .. #+end_FOO
(define-skeleton skel-org-block
  "Insert an org block, querying for type."
  "Type: "
  "#+begin_" str "\n"
  _ - \n
  "#+end_" str "\n")

(define-abbrev org-mode-abbrev-table "sblk" "" 'skel-org-block)

;; splantuml - PlantUML Source block
(define-skeleton skel-org-block-plantuml
  "Insert a org plantuml block, querying for filename."
  "File (no extension): "
  "#+begin_src plantuml :file " str ".png :cache yes\n"
  _ - \n
  "#+end_src\n")

(define-abbrev org-mode-abbrev-table "splantuml" "" 'skel-org-block-plantuml)

(define-skeleton skel-org-block-plantuml-activity
  "Insert a org plantuml block, querying for filename."
  "File (no extension): "
  "#+begin_src plantuml :file " str "-act.png :cache yes :tangle " str "-act.txt\n"
  (bh/plantuml-reset-counters)
  "@startuml\n"
  "skinparam activity {\n"
  "BackgroundColor<<New>> Cyan\n"
  "}\n\n"
  "title " str " - \n"
  "note left: " str "\n"
  "(*) --> \"" str "\"\n"
  "--> (*)\n"
  _ - \n
  "@enduml\n"
  "#+end_src\n")

(defvar bh/plantuml-if-count 0)

(defun bh/plantuml-if () 
  (incf bh/plantuml-if-count)
  (number-to-string bh/plantuml-if-count))

(defvar bh/plantuml-loop-count 0)

(defun bh/plantuml-loop () 
  (incf bh/plantuml-loop-count)
  (number-to-string bh/plantuml-loop-count))

(defun bh/plantuml-reset-counters ()
  (setq bh/plantuml-if-count 0
        bh/plantuml-loop-count 0)
  "")

(define-abbrev org-mode-abbrev-table "sact" "" 'skel-org-block-plantuml-activity)

(define-skeleton skel-org-block-plantuml-activity-if
  "Insert a org plantuml block activity if statement"
  "" 
  "if \"\" then\n"
  "  -> [condition] ==IF" (setq ifn (bh/plantuml-if)) "==\n"
  "  --> ==IF" ifn "M1==\n"
  "  -left-> ==IF" ifn "M2==\n"
  "else\n"
  "end if\n"
  "--> ==IF" ifn "M2==")

(define-abbrev org-mode-abbrev-table "sif" "" 'skel-org-block-plantuml-activity-if)

(define-skeleton skel-org-block-plantuml-activity-for
  "Insert a org plantuml block activity for statement"
  "Loop for each: " 
  "--> ==LOOP" (setq loopn (bh/plantuml-loop)) "==\n"
  "note left: Loop" loopn ": For each " str "\n"
  "--> ==ENDLOOP" loopn "==\n"
  "note left: Loop" loopn ": End for each " str "\n" )

(define-abbrev org-mode-abbrev-table "sfor" "" 'skel-org-block-plantuml-activity-for)

(define-skeleton skel-org-block-plantuml-sequence
  "Insert a org plantuml activity diagram block, querying for filename."
  "File appends (no extension): "
  "#+begin_src plantuml :file " str "-seq.png :cache yes :tangle " str "-seq.txt\n"
  "@startuml\n"
  "title " str " - \n"
  "actor CSR as \"Customer Service Representative\"\n"
  "participant CSMO as \"CSM Online\"\n"
  "participant CSMU as \"CSM Unix\"\n"
  "participant NRIS\n"
  "actor Customer"
  _ - \n
  "@enduml\n"
  "#+end_src\n")

(define-abbrev org-mode-abbrev-table "sseq" "" 'skel-org-block-plantuml-sequence)

;; sdot - Graphviz DOT block
(define-skeleton skel-org-block-dot
  "Insert a org graphviz dot block, querying for filename."
  "File (no extension): "
  "#+begin_src dot :file " str ".png :cache yes :cmdline -Kdot -Tpng\n"
  "graph G {\n"
  _ - \n
  "}\n"
  "#+end_src\n")

(define-abbrev org-mode-abbrev-table "sdot" "" 'skel-org-block-dot)

;; sditaa - Ditaa source block
(define-skeleton skel-org-block-ditaa
  "Insert a org ditaa block, querying for filename."
  "File (no extension): "
  "#+begin_src ditaa :file " str ".png :cache yes\n"
  _ - \n
  "#+end_src\n")

(define-abbrev org-mode-abbrev-table "sditaa" "" 'skel-org-block-ditaa)

;; selisp - Emacs Lisp source block
(define-skeleton skel-org-block-elisp
  "Insert a org emacs-lisp block"
  ""
  "#+begin_src emacs-lisp\n"
  _ - \n
  "#+end_src\n")

(define-abbrev org-mode-abbrev-table "selisp" "" 'skel-org-block-elisp)
#+end_src

我在工作中做备忘，依然会使用abbrev-mode。我写了第一个人名后就可以展开成完整的名字。 因此
当我写了 =mickey= 就会自动展开成 =Mickey Mouse= . 为创建缩写，只要输入快捷键
=C-x a i l= 来创建当前模式的缩写。


你所要做的就是，不要使用通用的单词，来作为你的缩写，因为abbrev-mode会自动扩展所有你写入的。
我发现当我输入 =plantuml= 就会碰到这个问题，非常讨厌。

我同样在c源代码中使用abbrev-mode。这个非常适合我。

*** PlantUml 活动图生成示例
:PROPERTIES:
:CUSTOM_ID: ActivityDiagramExample
:END:

当需要创建活动图时，我会用 =sif= 以及 =sfor= 添加IF以及FOR代码块，并产生自动唯一的id。

例如： 创建一个包含两个IFs以及两个FOR代码块的活动图。

创建图标： “sact RET test RET”

示例

#+begin_src plantuml :file test-act.png :cache yes :tangle test-act.txt :exports both
@startuml
skinparam activity {
BackgroundColor<<New>> Cyan
}

title test - 
note left: test
(*) --> "test"
--> (*)

@enduml
#+end_src

#+results[941b135a91506a3806dcb1dcc07c18b23c0cd608]:
[[file:test-act.png]]

将光标移动到-->(*)然后输入 “sif RET”

示例

#+begin_src plantuml :file test-act2.png :cache yes :tangle test-act2.txt :exports both
@startuml
skinparam activity {
BackgroundColor<<New>> Cyan
}

title test - 
note left: test
(*) --> "test"
if "" then
  -> [condition] ==IF1==
  --> ==IF1M1==
  -left-> ==IF1M2==
else
end if
--> ==IF1M2==
--> (*)

@enduml
#+end_src

#+results[0b3365856895b29376087110b72d8cd127d3b4f7]:
[[file:test-act2.png]]

（*）行重复执行

示例

#+begin_src plantuml :file test-act3.png :cache yes :tangle test-act3.txt :exports both
@startuml
skinparam activity {
BackgroundColor<<New>> Cyan
}

title test - 
note left: test
(*) --> "test"
if "" then
  -> [condition] ==IF1==
  --> ==IF1M1==
  -left-> ==IF1M2==
else
end if
--> ==IF1M2==
if "" then
  -> [condition] ==IF2==
  --> ==IF2M1==
  -left-> ==IF2M2==
else
end if
--> ==IF2M2==
--> (*)

@enduml
#+end_src

#+results[f1e8e6dfcb6cfc183b56196edb5769e53b7ad127]:
[[file:test-act3.png]]

通过“sfor RET line in file RET”以及"sfor RET address in addressbook RET",添加了两个for循环.

示例

#+begin_src plantuml :file test-act4.png :cache yes :tangle test-act4.txt :exports both
@startuml
skinparam activity {
BackgroundColor<<New>> Cyan
}

title test - 
note left: test
(*) --> "test"
if "" then
  -> [condition] ==IF1==
  --> ==IF1M1==
  -left-> ==IF1M2==
else
end if
--> ==IF1M2==
if "" then
  -> [condition] ==IF2==
  --> ==IF2M1==
  -left-> ==IF2M2==
else
end if
--> ==IF2M2==
--> ==LOOP1==
note left: Loop1: For each line in file
--> ==ENDLOOP1==
note left: Loop1: End for each line in file
--> ==LOOP2==
note left: Loop2: For each address in addressbook
--> ==ENDLOOP2==
note left: Loop2: End for each address in addressbook

--> (*)

@enduml
#+end_src

#+results[dffc80c1690d0ffc945596218c6264aa99f52ec5]:
[[file:test-act4.png]]

当需要调整对齐时候，我会使用列编辑模式来处理。

** 聚焦当前工作
:PROPERTIES:
:CUSTOM_ID: FocusOnCurrentWork
:END:

有多种方式可以达到这个要求，选择合适自己的方式就行。

*** 执行 =bh/org-todo= 限制子任务树显示
:PROPERTIES:
:CUSTOM_ID: NarrowToSubtree
:END:

将=f5= 以及 =s-f5= 分别绑定到限制显示范围以及恢复显示范围功能上。

我就可以这样使用：

    - T （任务）C-c / t 在当前缓冲区
    - N （限制）只显示该任务子树
    - U （向上）显示父任务子树
    - P （项目）显示父项目的子任务树
    - F （文件）只显示当前文件以及文件限制

但是agenda视图依然保持显示所有缓冲区任务，这方便聚焦我们在做的事情上。

#+header: :tangle yes
#+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'bh/org-todo)

(defun bh/org-todo (arg)
  (interactive "p")
  (if (equal arg 4)
      (save-restriction
        (bh/narrow-to-org-subtree)
        (org-show-todo-tree nil))
    (bh/narrow-to-org-subtree)
    (org-show-todo-tree nil)))

(global-set-key (kbd "<S-f5>") 'bh/widen)

(defun bh/widen ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-agenda-remove-restriction-lock)
        (when org-agenda-sticky
          (org-agenda-redo)))
    (widen)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "W" (lambda () (interactive) (setq bh/hide-scheduled-and-waiting-next-tasks t) (bh/widen))))
          'append)

(defun bh/restrict-to-file-or-follow (arg)
  "Set agenda restriction to 'file or with argument invoke follow mode.
I don't use follow mode very often but I restrict to file all the time
so change the default 'F' binding in the agenda to allow both"
  (interactive "p")
  (if (equal arg 4)
      (org-agenda-follow-mode)
    (widen)
    (bh/set-agenda-restriction-lock 4)
    (org-agenda-redo)
    (beginning-of-buffer)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "F" 'bh/restrict-to-file-or-follow))
          'append)

(defun bh/narrow-to-org-subtree ()
  (widen)
  (org-narrow-to-subtree)
  (save-restriction
    (org-agenda-set-restriction-lock)))

(defun bh/narrow-to-subtree ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-with-point-at (org-get-at-bol 'org-hd-marker)
          (bh/narrow-to-org-subtree))
        (when org-agenda-sticky
          (org-agenda-redo)))
    (bh/narrow-to-org-subtree)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "N" 'bh/narrow-to-subtree))
          'append)

(defun bh/narrow-up-one-org-level ()
  (widen)
  (save-excursion
    (outline-up-heading 1 'invisible-ok)
    (bh/narrow-to-org-subtree)))

(defun bh/get-pom-from-agenda-restriction-or-point ()
  (or (and (marker-position org-agenda-restrict-begin) org-agenda-restrict-begin)
      (org-get-at-bol 'org-hd-marker)
      (and (equal major-mode 'org-mode) (point))
      org-clock-marker))

(defun bh/narrow-up-one-level ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
          (bh/narrow-up-one-org-level))
        (org-agenda-redo))
    (bh/narrow-up-one-org-level)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "U" 'bh/narrow-up-one-level))
          'append)

(defun bh/narrow-to-org-project ()
  (widen)
  (save-excursion
    (bh/find-project-task)
    (bh/narrow-to-org-subtree)))

(defun bh/narrow-to-project ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
          (bh/narrow-to-org-project)
          (save-excursion
            (bh/find-project-task)
            (org-agenda-set-restriction-lock)))
        (org-agenda-redo)
        (beginning-of-buffer))
    (bh/narrow-to-org-project)
    (save-restriction
      (org-agenda-set-restriction-lock))))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "P" 'bh/narrow-to-project))
          'append)

(defvar bh/project-list nil)

(defun bh/view-next-project ()
  (interactive)
  (let (num-project-left current-project)
    (unless (marker-position org-agenda-restrict-begin)
      (goto-char (point-min))
      ; Clear all of the existing markers on the list
      (while bh/project-list
        (set-marker (pop bh/project-list) nil))
      (re-search-forward "Tasks to Refile")
      (forward-visible-line 1))

    ; Build a new project marker list
    (unless bh/project-list
      (while (< (point) (point-max))
        (while (and (< (point) (point-max))
                    (or (not (org-get-at-bol 'org-hd-marker))
                        (org-with-point-at (org-get-at-bol 'org-hd-marker)
                          (or (not (bh/is-project-p))
                              (bh/is-project-subtree-p)))))
          (forward-visible-line 1))
        (when (< (point) (point-max))
          (add-to-list 'bh/project-list (copy-marker (org-get-at-bol 'org-hd-marker)) 'append))
        (forward-visible-line 1)))

    ; Pop off the first marker on the list and display
    (setq current-project (pop bh/project-list))
    (when current-project
      (org-with-point-at current-project
        (setq bh/hide-scheduled-and-waiting-next-tasks nil)
        (bh/narrow-to-project))
      ; Remove the marker
      (setq current-project nil)
      (org-agenda-redo)
      (beginning-of-buffer)
      (setq num-projects-left (length bh/project-list))
      (if (> num-projects-left 0)
          (message "%s projects left to view" num-projects-left)
        (beginning-of-buffer)
        (setq bh/hide-scheduled-and-waiting-next-tasks t)
        (error "All projects viewed.")))))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "V" 'bh/view-next-project))
          'append)
#+end_src

这些辅助函数，通过限制显示范围，方便临时隐藏org文件中细节。任务通过折叠高亮
等方式显示未完成的任务。

我每天执行很多 =f5= (或者 =T= 快捷键)。它主要做的事情就是 =org-narrow-to-subtree= 以及
=C-c / t= 结合保证缓冲区不要显示太多不必要的任务。我使用 =S-f5=(或者像 =U= =W= =F= 之类
的快捷键)来切换到正常显示状态。

*** 在agenda限制任务子树显示
:PROPERTIES:
:CUSTOM_ID: AgendaNarrowToSubtree
:END:

=C-c C-x <= 开启子树agenda限制。这样agenda视图只显示当前子树。但是隐藏任务相关的
警告以及通知设置，在agenda之外依然正常工作。通过快捷键 =C-c C-x >= 关闭agenda限制
，让agenda正常显示所有任务。

#+header: :tangle yes
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "\C-c\C-x<" 'bh/set-agenda-restriction-lock))
          'append)

(defun bh/set-agenda-restriction-lock (arg)
  "Set restriction lock to current task subtree or file if prefix is specified"
  (interactive "p")
  (let* ((pom (bh/get-pom-from-agenda-restriction-or-point))
         (tags (org-with-point-at pom (org-get-tags-at))))
    (let ((restriction-type (if (equal arg 4) 'file 'subtree)))
      (save-restriction
        (cond
         ((and (equal major-mode 'org-agenda-mode) pom)
          (org-with-point-at pom
            (org-agenda-set-restriction-lock restriction-type))
          (org-agenda-redo))
         ((and (equal major-mode 'org-mode) (org-before-first-heading-p))
          (org-agenda-set-restriction-lock 'file))
         (pom
          (org-with-point-at pom
            (org-agenda-set-restriction-lock restriction-type))))))))
#+end_src

这允许我从agenda直接限制任务显示，我通常在agenda里边做很多工作，这样就非常方便。

与自动移到项目最上层任务比较 限制任务显示就显得不够惊喜了-- 我曾经就是这么做的。
如果当前项目显示有限，需要向上查看，先移动到上面，再做限制。

往往一个项目有很多任务在里边，限制显示一个项目也会有很多要显示的，所以我想限制只
显示其中一个子树。这就是为什么我保留 =N= 以及 =U= 来调整显示区域。

我为agenda视图以及org-buffer添加了其他的新的快捷键来控制子树，父任务以及项目任务，当然也
包含相应的取消限制的快捷键。这些快捷键既适合在agenda中也适合在org 文件中使用。

- =N= 限制显示当前任务子树
  功能和 =C-c C-x <= 一致

- =U= 将限制扩展到该子树对应的父任务
  该功能对父子树做限制

- =P= 限制整个任务所对应的项目
  将会向上找到最上层 =TODO= 关键字选择整个子树限制显示

- =W= 取消限制，显示原样

#+header: :tangle yes
#+begin_src emacs-lisp
;; Limit restriction lock highlighting to the headline only
(setq org-agenda-restriction-lock-highlight-subtree nil)
#+end_src

*** 限制agenda只显示一个文件
:PROPERTIES:
:CUSTOM_ID: AgendaNarrowToFile
:END:

你也可以只让agenda显示单个文件的视图，当然有多种方法可以做到这点。

可以在第一个标题行前的任意行使用agenda的限制快捷键 =C-c C-x <= 来限制agenda视图
只显示当前文件视图。这相当于使用前置参数（ =C-u C-c C-x <= ）。这种限制一直有效，
如果需要取消，需要执行 = C-c C-x >=.

同样，在agenda中执行 =C-u C-c c-x <= 也可以达到这个效果。

另一种方法是通过 =F12 < a= 在org 文件中启动agenda视图。这就会让agenda只显示
该文件内容。我通常会对非 =org-agenda-files= 变量定义的文件会通过这种方法查看
agenda视图。

** agenda视图开启
:PROPERTIES:
:CUSTOM_ID: TuningAgendaViews
:END:

有很多定制化agenda视图方法来显示任务细节。这个章节会介绍我的工作流中使用到的
一些定制化。

*** 高亮显示当前agenda行
:PROPERTIES:
:CUSTOM_ID: HighlightCurrentAgendaLine
:END:

下面的代码来自我的 =.emacs= 文件，高亮显示当前的agenda行。这会让该任务高亮显示，
这样就不会选错任务，从而导致对错的任务执行操作。

模式行中计时信息也会反向背景显示。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)
#+end_src

#+header: :tangle no
#+begin_src emacs-lisp
;; The following custom-set-faces create the highlights
(custom-set-faces
  ;; custom-set-faces was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(org-mode-line-clock ((t (:background "grey75" :foreground "red" :box (:line-width -1 :style released-button)))) t))
#+end_src

*** 在全局todo列表中显示时间戳
:PROPERTIES:
:CUSTOM_ID: GlobalTodoListsShowAllTasks
:END:

带（=SCHEDULED:= =DEADLINE:= 以及其他日期）在agenda中能够合理显示出来。agenda
视图（=F12 a=）只会让任务在一个地方显示（要么在日历中，要么在其他的agenda列表显示）。
我现在很少在org-mode使用全局列表查找(=F12 t=, =F12 m=)。只有需要找特定任务时候，我才会
这么做。现在该列表包含 _所有_ , 因此我能够找到我想要的任务。

agenda中不会显示那些截止日期以及计划在将来发生的任务，因此你能够先忽略他们，直到合适
时候他们才会出现在agenda列表中。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done t)
#+end_src

*** 使用日记来记录假期以及纪念日
:PROPERTIES:
:CUSTOM_ID: DiaryForAppointments
:END:

我并不用emacs日记来记录所有事情， 但是我还是希望能在我的agenda中查看到节日信息。
这能方便我在不需要工作时候(节假日)，做合适的计划。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-include-diary nil)
(setq org-agenda-diary-file "~/git/org/diary.org")
#+end_src

日记文件包含着由capture mode创建的约会模板生成的 =时间树= 项。我也会用它记录一些突发的
需要计时的任务。

我不用 =~/diary= 文件。只保留一个空文件，为了使得emacs能正常工作。我使用org-mode的
日记。在agenda视图中通过 =i= 来创建一个日期项，并同步到 =~/git/org/diary.org= 文件中。

我将日历中的节假日导入我的 =todo.org= ，文件格式如下：

#+begin_src org :exports src
,#+FILETAGS: PERSONAL
,* Appointments
  :PROPERTIES:
  :CATEGORY: Appt
  :ARCHIVE:  %s_archive::* Appointments
  :END:      
,** Holidays
   :PROPERTIES:
   :Category: Holiday
   :END:
   %%(org-calendar-holiday)
,** Some other Appointment
   ...
#+end_src

我使用下面的设置使得agenda可以正常显示日志时间。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-insert-diary-extract-time t)
#+end_src

*** 包含归档文件查找
:PROPERTIES:
:CUSTOM_ID: SearchesIncludeArchiveFiles
:END:

我只用一个归档文件用来归档我所有的org-mode相关的项目文件。这样当我需要查一些信息时，
可以既查看当前文件也可以查看归档文件，方便我从归档文件中找到想要的信息。

这个功能我并不常用，但是有备无患，如果哪天需要，我还是可以立马能使用。

#+header: :tangle yes
#+begin_src emacs-lisp
;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))
#+end_src

*** agenda视图调整
:PROPERTIES:
:CUSTOM_ID: AgendaViewTweaks
:END:

下面列举的是agenda视图需要定制化的地方：
- 显示重复的任务
- 在agenda中显示空日期
- 调整任务排序
- agenda周视图以周日开始
- 显示网格
- 在底部显示习惯

我定制化了排序函数，通过该函数，agenda中任务都是按照重要性来排序的。每日agenda视图
按照如下顺序排序：

1. 有时间戳的在前面显示，因此就不会忽略这些任务了
2. 今日的任务（带时间戳的活跃任务，但并不包含计划任务或者截止任务）
3. 今日截止任务
4. 后续截止任务
5. 今日计划任务
6. 待定的有截止日期的任务（很快可能要处理）
7. 后续计划条目
8. 习惯

这个排序算法可能并不特比完美，但是能够正常工作。

下面是在我 =.emacs= 中的相关配置：

#+header: :tangle yes
#+begin_src emacs-lisp
;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Sorting order for tasks on the agenda
(setq org-agenda-sorting-strategy
      (quote ((agenda habit-down time-up user-defined-up effort-up category-keep)
              (todo category-up effort-up)
              (tags category-up effort-up)
              (search category-up))))

;; Start the weekly agenda on Monday
(setq org-agenda-start-on-weekday 1)

;; Enable display of the time grid so we can see the marker for the current time
(setq org-agenda-time-grid (quote ((daily today remove-match)
                                   #("----------------" 0 16 (org-heading t))
                                   (0900 1100 1300 1500 1700))))

;; Display tags farther right
(setq org-agenda-tags-column -102)

;;
;; Agenda sorting functions
;;
(setq org-agenda-cmp-user-defined 'bh/agenda-sort)

(defun bh/agenda-sort (a b)
  "Sorting strategy for agenda items.
Late deadlines first, then scheduled, then non-late deadlines"
  (let (result num-a num-b)
    (cond
     ; time specific items are already sorted first by org-agenda-sorting-strategy

     ; non-deadline and non-scheduled items next
     ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))

     ; deadlines for today next
     ((bh/agenda-sort-test 'bh/is-due-deadline a b))

     ; late deadlines next
     ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))

     ; scheduled items for today next
     ((bh/agenda-sort-test 'bh/is-scheduled-today a b))

     ; late scheduled items next
     ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))

     ; pending deadlines last
     ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))

     ; finally default to unsorted
     (t (setq result nil)))
    result))

(defmacro bh/agenda-sort-test (fn a b)
  "Test for agenda sort"
  `(cond
    ; if both match leave them unsorted
    ((and (apply ,fn (list ,a))
          (apply ,fn (list ,b)))
     (setq result nil))
    ; if a matches put a first
    ((apply ,fn (list ,a))
     (setq result -1))
    ; otherwise if b matches put b first
    ((apply ,fn (list ,b))
     (setq result 1))
    ; if none match leave them unsorted
    (t nil)))

(defmacro bh/agenda-sort-test-num (fn compfn a b)
  `(cond
    ((apply ,fn (list ,a))
     (setq num-a (string-to-number (match-string 1 ,a)))
     (if (apply ,fn (list ,b))
         (progn
           (setq num-b (string-to-number (match-string 1 ,b)))
           (setq result (if (apply ,compfn (list num-a num-b))
                            -1
                          1)))
       (setq result -1)))
    ((apply ,fn (list ,b))
     (setq result 1))
    (t nil)))

(defun bh/is-not-scheduled-or-deadline (date-str)
  (and (not (bh/is-deadline date-str))
       (not (bh/is-scheduled date-str))))

(defun bh/is-due-deadline (date-str)
  (string-match "Deadline:" date-str))

(defun bh/is-late-deadline (date-str)
  (string-match "\\([0-9]*\\) d\. ago:" date-str))

(defun bh/is-pending-deadline (date-str)
  (string-match "In \\([^-]*\\)d\.:" date-str))

(defun bh/is-deadline (date-str)
  (or (bh/is-due-deadline date-str)
      (bh/is-late-deadline date-str)
      (bh/is-pending-deadline date-str)))

(defun bh/is-scheduled (date-str)
  (or (bh/is-scheduled-today date-str)
      (bh/is-scheduled-late date-str)))

(defun bh/is-scheduled-today (date-str)
  (string-match "Scheduled:" date-str))

(defun bh/is-scheduled-late (date-str)
  (string-match "Sched\.\\(.*\\)x:" date-str))
#+end_src

*** 便利贴式的agenda
:PROPERTIES:
:CUSTOM_ID: StickyAgendas
:END:

便利贴式的agenda允许你同时创建不止一个agenda视图。你可以快速切换到该视图而不需要额外的通过
agenda命令重建agenda视图。如果已经存在，那么就会显示存在视图。快捷键 =g= 可以强制重新生成
agenda视图。

我通常会使用两个agenda视图（=F12 a= 每日每周视图 =F12 SPC= 项目视图）。

开启该功能的配置如下：

#+header: :tangle yes
#+begin_src emacs-lisp
;; Use sticky agenda's so they persist
(setq org-agenda-sticky t)
#+end_src

** 清单处理
:PROPERTIES:
:CUSTOM_ID: ChecklistHandling
:END:

清单对于那种重复性并包含非常多需要做的事情的任务适用。曾经,当清单任务完成后，我会手动
清除复选框的选择状态，以保证后续能继续执行。但是现在不会这样麻烦了，因为有 =rog-checklist= 功能，
当重复的任务标记完成时候，清单中复选框就会自动清除选择状态。

在你的.emacs中添加如下脚本来完成上述功能。

#+header: :tangle no
#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "~/git/org-mode/contrib/lisp"))

(require 'org-checklist)
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp :exports none
;; The following setting is different from the document so that you
;; can override the document path by setting your path in the variable
;; org-mode-user-contrib-lisp-path
;;
(if (boundp 'org-mode-user-contrib-lisp-path)
    (add-to-list 'load-path org-mode-user-contrib-lisp-path)
  (add-to-list 'load-path (expand-file-name "~/git/org-mode/contrib/lisp")))

(require 'org-checklist)
#+end_src

当需要在任务中使用时候，只需要设置 =RESET_CHECK_BOXES= 为 =t= .
像下面一样：

#+begin_src org :exports src
,* TODO Invoicing and Archive Tasks [0/7]
  DEADLINE: <2009-07-01 Wed +1m -0d> 
  :PROPERTIES:
  :RESET_CHECK_BOXES: t
  :END:

  - [ ] Do task 1
  - [ ] Do task 2
  ...
  - [ ] Do task 7
#+end_src

** 备份
:PROPERTIES:
:CUSTOM_ID: Backups
:END:

= 及时备份那些还没有完成的的任务 =

10年前，我曾经因为没有很好的备份手段而丢失掉大量数据。那时我就告诫自己 = 我以后
再也不想丢失任何数据 = 。到现在为止确实没有丢失过了:).

我在备份时候很谨慎。org模式怎么来帮助完成备份的？确实没有花很大力气，并不是我不想
花很多时间来备份--它时刻在发生--这节省我时间，并可以把这些时间花在处理其他更有趣
的事情上。

我备份的原则就是方便恢复数据--但是这条却并不容易实现。也并不需要非常容易/快速从备
份中恢复，因为从备份数据将其恢复也并不经常发生。恢复时候节省时间没什么意义。相反，
我希望备份时候能够快速无痛点，因为我经常做备份。

10年前我就自动化网络备份了，当然现在依然再用。我所用的所有电脑从网络驱动获取
每日备份。每个月收集一次并写入可移动硬盘。

我有个月备份任务，当满一个月，就会提醒我备份当前数据到外部存储中。我很开心
现在备份执行时间变得越来越少。

自从 =git= 进入我生活， 多主机备份 =git= 代码仓库就变得更加简单了。当前只要
有修改推送发送远程仓库，就会自动备份该仓库中所有东西。

** 处理受阻任务
:PROPERTIES:
:CUSTOM_ID: HandlingBlockedTasks
:END:

受阻任务是那些包含子任务的任务，并且该任务至少有一个子任务不处于done状态。
受阻任务在agenda视图中以灰色来显示。

可以通过如下脚本，启用受阻任务功能：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src

这个设置会阻碍试图将包含未在完成状态子任务的任务，设置为完成状态。除了重复
任务外。这样做非常好。对于重复任务，我通常会在任务下面添加很多=TODO=状态
子任务，并且这些子任务也不一定要这个周期完成，可以在下个周期完成。

当然，可以通过快捷键 =C-u C-u C-u C-c C-t= 临时修改任务设置,但我记不住
这组快捷键。我在重复任务设置了一个永久属性：

#+begin_src org :exports src
,* TODO New Repeating Task
  SCHEDULED: <2009-06-16 Tue +1w>
  :PROPERTIES:
  :NOBLOCKING: t
  :END:
  ...
,** TODO Subtask  
#+end_src
这可使得 =新的重复任务= 即使有子任务没有完成，也可以正常对父任务设置完成状态，不会受阻。

通常我会按照一个给定的顺序来完成任务。 org-mode有个 =ORDERED= 属性来对子
任务做顺序限制。

#+begin_src org :exports src
,* TODO Some Task
  :PROPERTIES:
  :ORDERED: t
  :END:
,** TODO Step 1
,** TODO Step 2
,** TODO Step 3  
#+end_src

这种情况下，你需要在完成 =Step 1= 后再去完成 =Step 2= 。org mode会阻止你去
对一个前面还有不在完成状态的任务，设置完成状态。

** org任务结构以及展示
:PROPERTIES:
:CUSTOM_ID: OrgTaskStructureAndPresentation
:END:

本节主要介绍我处理org文件时，是怎么设置任务显示的大量定制化脚本。

*** 控制标题前置符号显示
:PROPERTIES:
:CUSTOM_ID: DisplayLeadingStars
:END:

对于任务的前置符号(*)，org-mode可以定制化其是否显示。也有可能在其它层级中出现标题，
这样前置符号以及标题就可以在子树层对齐。

为使得org 显示前置符号，可以做如下设置

#+header: :tangle yes
#+begin_src emacs-lisp 
(setq org-hide-leading-stars nil)
#+end_src

我当前使用 org-indent mode来隐藏前置符号(*).

*** org-indent模式
:PROPERTIES:
:CUSTOM_ID: OrgIndentMode
:END:

我最近开始使用org-indent模式。我很喜欢这个模式。它会在org文件中移除这些对齐符号，
但是当编辑缓冲区时，这些对齐就会显示。

org-indent模式当org-odd-level-only 值为true时显示，但是显示效果比我之前的设置更加整洁。
因此我更喜欢它。

我的org-indent模式在emacs启动时自动生效：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-startup-indented t)
#+end_src

*** 处理空行
:PROPERTIES:
:CUSTOM_ID: HandlingBlankLines
:END:

空行很邪恶 :). 他们自动在标题行之间插入，但是当标题行折叠后我并不想看到他们。
当我用 =TAB= (循环）折叠标题时，不希望在标题间看到空行。

下列设置保证隐藏空行，这样在标题折叠后，就会更加精炼整洁。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-cycle-separator-lines 0)
#+end_src

我发现在列表以及大纲显示空行也有点令人讨厌。为了获取list列表后内容，你需要包含
空行--合适缩放内容。我大部分list没有内容，所有我也不希望list后面有空行。

下面设置，防止在创建标题时插入空行，但是允许list兼容空行。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-blank-before-new-entry (quote ((heading)
                                         (plain-list-item . auto))))
#+end_src

*** 快速添加不含当前任务内容的任务。
:PROPERTIES:
:CUSTOM_ID: AddingNewTasks
:END:

为在项目文件中创建一个新标题非常方便，可以通过快捷键 =C-RET= ， =C-S-RET=,
=M-RET= , 以及 =M-S-RET= . 这将插入一个新标题并包含 =TODO= 关键字。

通过如下设置：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-insert-heading-respect-content nil)
#+end_src

org在光标行通过 =M-= 插入大纲，通过 =C-= 插入内容。内容设置对于 =C-= 版本临时开启的，
会添加新标题. 所以可以通过快捷键 =C-S-RET= 在当前条目上执行后，就会在后面
添加一个新标题。也可以通过 =M-S-RET= 将一个标题分成两个。

*** 备忘放在任务前部
:PROPERTIES:
:CUSTOM_ID: NotesAtTop
:END:

我通过 =C-c C-z= 创建一个备忘任务(或者在agenda中执行 =z= ）。有时候修改任务
状态也会弹出要求输入备忘(e.g. 移动到 =WAITING= 状态，就会弹出备忘，我会输入
进入等待状态的原因).这些备忘保存在任务最前端，因此当取消折叠任务时，备忘就会显示
最前端。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-reverse-note-order nil)
#+end_src

*** 查找并显示结果
:PROPERTIES:
:CUSTOM_ID: SearchingResults
:END:

当需要在你的org文件中查询数据，org-mode的查找能力就起作用了。 =C-c / /= 会
做正则表达式查找当前文件，并在org文件折叠视图中显示匹配结果。

当使用如下设置，我的org模式就可以显示匹配项的任务，以及邻近的任务(并不是所有相邻任务)：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-show-following-heading t)
(setq org-show-hierarchy-above t)
(setq org-show-siblings (quote ((default))))
#+end_src

这使得查找结果显示更加精简，也能够避免由于使用 =C-k= 从org文件中剪切太多的数据。剪切折叠
数据(包括...)非常危险，因为它也将那些你看不到的文本内容(包括相邻的子任务）也会
剪切掉。正因为这样，我总是在显示查找结果时，也会显示大纲。

*** 编辑以及特殊按键处理
:PROPERTIES:
:CUSTOM_ID: SpecialKeyHandling
:END:

在处理标题时，org-mode快捷键C-a, C-e以及C-k快捷键都能正常工作。我也会用一些设置
来处理粘贴（yanks）子任务以及根据任务调整子树层级。通过查看帮助文档(=C-h v org-yank-adjust-
subtrees=)， 可以查看详细细节以及如何使用。

我使用 =org-special-ctrl-a/e= ，能够快速移动光标到标题开始结束位置。 我使用 =M-m= 或者 =C-a C-a=
来移动光标到行开始处。 因此，快捷键在org mode依然很好工作，并且通过快捷键 =C-a= ，
我能够将光标定位到行开始处。

** 附件
:PROPERTIES:
:CUSTOM_ID: Attachments
:END:

附件可以很方便在你的项目相关org-mode文件之外，添加关联的大量数据。在附件功能出来
之前我会在我的org文件中包含非常多的SQL代码段，来保存项目数据库的修改。这导致我的org
文件非常大。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-id-method (quote uuidgen))
#+end_src

假如说，你想把 =x.sql= 添加到当前任务中。在 =/tmp/x.sql= 中创建文件保存。

通过快捷键 =C-c C-a a= ，添加附件，并输入文件名: =x.sql=.这将为任务生成一个
唯一ID，然后把文件拷贝到附件目录。

#+begin_src org :exports src
,* Attachments                                                        :ATTACH:
  :PROPERTIES:
  :Attachments: x.sql
  :ID:       f1d38e9a-ff70-4cc4-ab50-e8b58b2aaa7b
  :END:  
#+end_src

附件被保存在 =data/f1/d38e9a-ff70-4cc4-ab50-e8b58b2aaa7b/=.它的具体位置对
我来说并不重要--只要它保存下来了并且能够方便取得就可以了。org-mode拷贝原来文件
=/tmp/x.sql= 到备份目录。

对于有附件的任务，都会添加一个 =ATTACH= 标签，因此你可以很方便通过tag标签找到这些任务。

通过 =C-c C-a o= 打开一个带有附件的任务。这个命令会弹出输入要打开文件的提示，按 =TAB=
就可以自动补全。

=ID= 对于每个任务都会生成一个唯一的。

当然也可以自己定义附件存储位置，但是我并不需要这么做 -- 存在默认位置就行，只要能找到就可以了。

我将我的org文件所有附件，都存储在子目录 =data= 中。这样就可以通过 =git= 来管理。
当有附件添加，我就可以直接push到远程仓库中。

** 截止日以及agenda可视化
:PROPERTIES:
:CUSTOM_ID: DeadlinesAndAgendaVisibility
:END:

截止日在生活必不可少。默认我会在agenda视图中显示30天内的任务。

下面设置可以完成这个目的：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-deadline-warning-days 30)
#+end_src

这样我就有足够时间在截止日前完成这个任务。

** 将表格导出成CSV格式
:PROPERTIES:
:CUSTOM_ID: TableExportToCSV
:END:

我有时会为任务添加org-mode表格，用来记录一些项目相关数据。我的客户也喜欢这种表格。
当然在org mode中，很方便将表格导出成HTML格式，但是对于希望编辑这种表格的人来说，
就不是特别方便。为解决这个问题，我会将表格导出成逗号分割(CSV)格式然后发给客户
(或者通过表格读取然后发送给可以）

org-mode可以将表格导出成TAB或者逗号分隔的格式。我设置导出默认的CSV格式脚本如下：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-table-export-default-format "orgtbl-to-csv")
#+end_src
我默认只导出成CSV格式，所有当导出时我只敲击RETURN来完成导出工作。

为导出下面表格，我将光标移动到表格里边然后执行 =M-x org-table-export=
，然后会提示输入名字以及格式，默认是CSV格式。

|   One |    Two | Three |
|-------+--------+-------|
|     1 |      1 |     2 |
|     3 |      6 |     5 |
|  fred |    kpe |  mary |
| 234.5 | 432.12 | 324.3 |

这将导出下列格式的数据文件

#+begin_src csv
One,Two,Three
1,1,2
3,6,5
fred,kpe,mary
234.5,432.12,324.3
#+end_src

** 最小化Emacs Frames
:PROPERTIES:
:CUSTOM_ID: MinimizeFrames
:END:

我的org文件中包含各种各样的email链接，网页以及其他文件链接。下面设置控制
org-mode处理链接方法。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-link-frame-setup (quote ((vm . vm-visit-folder)
                                   (gnus . org-gnus-no-new-news)
                                   (file . find-file))))

; Use the current window for C-c ' source editing
(setq org-src-window-setup 'current-window)
#+end_src

我喜欢所有链接都在一个窗口打开，这样我就不需要在我的窗口中管理多个frame了。通常
我全屏工作，链接都是在这个窗口打开，这样工作方式很适合我。

我如果需要处理多个文件，我会手动通过快捷键 =C-x 5 2= 创建第二个frame或者用
快捷键 =C-x 4 2= 或者 =C-x 4 3= 分割窗口。当需要访问文件时，会将当前窗口内容替换
成新内容。

** 日志相关的
:PROPERTIES:
:CUSTOM_ID: LoggingStuff
:END:

我大部分日志是通过全局 =org-todo-keywords= 来控制。

我的日志设置如下：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-log-done (quote time))
(setq org-log-into-drawer t)
(setq org-log-state-notes-insert-after-drawers nil)
#+end_src

我的 =org-todo-keywords= 设置如下：

#+header: :tangle no
#+begin_src emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))
#+end_src

当任务状态变化发生时, 日志就会被记录下来：
- 达到 =DONE= 状态或者从 =DONE= 状态退出
- 到 =WAITING= 状态(包含备忘）或者退出 =WAITING= 状态
= 到 =HOLD= 状态
- 到 =CANCELLED= 状态（包含备忘）或者退出 =CANCELLED= 状态。

我将计时信息以及状态信息记录在任务 =LOGBOOK= 抽屉中，以保持我的任务整洁。如果一个任务在
等待状态，那么在LOGBOOK里，就会显示等待原因，LOGBOOK也会处于展开状态，用来提示信息。
在agenda视图中，只要对任务单击 =SPC= 就可以取得LOGBOOK信息。

** 限制任务计时
:PROPERTIES:
:CUSTOM_ID: LimitingTimeSpentOnTasks
:END:

org-mode新引入一个非常棒的功能，就是一个任务评估时间到的时候会发送通知。我用这个功能来限制
每天某些任务执行时间。

例如，这个文档我已经花了将近2个月时间。我想尽快把它完成但是我没法只做这件事，这样
其他事情就没法做了。我想每天做点，比如限制每天只花1个小时在org-mode文档编写上。

因此我建了下面一个任务：

#+begin_src org :exports src
,* NEXT Document my use of org-mode
  :LOGBOOK:...
  :PROPERTIES:
  :CLOCK_MODELINE_TOTAL: today
  :Effort:   1:00
  :END:  
#+end_src

这个任务有一个小时评估时间，当我开始做这个任务时候，mode-line显示如下

: --:**  org-mode.org   91% (2348,73) Git:master  (Org Fly yas Font)-----[0:35/1:00 (Document my use of org-mode)]-------

我今天在这个项目中已经花了35分钟了。

我会设置一个报警声，当评估时间到了的时候就会想起星际迷航声音(是的，我是星际迷）。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-clock-sound "/usr/local/lib/tngchime.wav")
#+end_src

当一个小时评估时间到了，报警声就会想起，并且会弹出消息提示这个任务应该完成了。如果
我切换到其他任务，又切换回来，每次切换回来报警声都会想起来。这让我不得不做其他工作
:)

你也可以对重复任务做相应设置。默认情况下最后一次时间将会被记录下来。对于重复任务
mode-line时间显示的是最后一次计时。这方便几天后来评估自己花的时间。

** 习惯跟踪
:PROPERTIES:
:CUSTOM_ID: HabitTracking
:END:

John Wiegley最近在org-mode中添加了对习惯跟踪的功能支持。

我有很多习惯(有些是不好的习惯），但是我还是希望来改进并建立一些好的习惯。这就是
习惯跟踪做的事。它通过图形形式显示在agenda视图上，显示出你的习惯做的怎么样。

我有如下习惯：

- 手洗碟子
- 30分钟快步走
- 打扫家庭卫生

等等。大部分习惯需要规律性完成，所以有时候需要给点压力才能这么做。为跟踪习惯是否正常
完成，需要记录状态切换日志。

习惯任务与一般的任务很像，除了它设置了特别的 =属性= 。该属性被设置为习惯，有个
=计划=  时间项，就像下面这样：

#+begin_src org :exports src
,* TODO Update Org Mode Doc
  SCHEDULED: <2009-11-21 Sat .+7d/30d>
  [2009-11-14 Sat 11:45]
  :PROPERTIES:
  :STYLE: habit
  :END:  
#+end_src

这样习惯任务就可以和一般任务有所区别，agenda视图就会把它当做一个习惯任务来显示。
当习惯完成后，并被标记完成后，在agenda视图中就根据计划项，显示下次任务发生时间。
(=.+7d=).

=SCHEDULED= 项特殊地方是，我希望这个任务每天都被执行，或者每两天要执行。如果3天没有
标记习惯完成，那么在agenda视图中它就会显示红色，表示我很久没有执行这个习惯了。

如果习惯被忽略了，那么也不是什么世界末日的大事。你可以通过 =K= 键来在agenda显示或隐藏习惯
任务。

如下是我的习惯设置：

#+header: :tangle yes
#+begin_src emacs-lisp
; Enable habit tracking (and a bunch of other modules)
(setq org-modules (quote (org-bbdb
                          org-bibtex
                          org-crypt
                          org-gnus
                          org-id
                          org-info
                          org-jsinfo
                          org-habit
                          org-inlinetask
                          org-irc
                          org-mew
                          org-mhe
                          org-protocol
                          org-rmail
                          org-vm
                          org-wl
                          org-w3m)))

; position the habit graph on the agenda to the right of the default
(setq org-habit-graph-column 50)
#+end_src

每日，我会通过 =K= 在agenda中关闭习惯任务显示。当关闭后，这个设置就会永久保持了，
当我的emacs后台运行几天后，习惯任务也不会自动显示在agenda视图中。为保证我每天早
上都能看到习惯执行情况，我做了如下设置，这样每天早上，习惯任务就能显示在agenda视图中。

#+header: :tangle yes
#+begin_src emacs-lisp
(run-at-time "06:00" 86400 '(lambda () (setq org-habit-show-habits t)))
#+end_src

** 对于习惯只记录完成状态修改
:PROPERTIES:
:CUSTOM_ID: HabitsLogDone
:END:

我通常将习惯放在第一层任务 =* Habits= 中，并且仅当任务完成时候才会记录属性。这样
我就可以在取消一个习惯时候不会记录一个时间戳，从而让这些信息填满习惯任务中.当要
取消一个习惯，只要从agenda中移除。如果习惯没有执行，那么没法重做(例如早上6点起床）
，对于没有遵循的习惯任务，就不能标记成完成。我就会取消每日重复的习惯。

我的习惯任务就像下面一样-我习惯为每个org文件都添加习惯标题。

#+begin_src org :exports src
,* Habits
  :PROPERTIES:
  :LOGGING:  DONE(!)
  :ARCHIVE:  %s_archive::* Habits
  :END:  
#+end_src

** 自动复原模式
:PROPERTIES:
:CUSTOM_ID: AutoRevertMode
:END:

我使用git在我的笔记本以及我的工作站之间同步org-mode文件。常规执行流程是保存当前修改，
推送到repo中，在其他系统中获取，然后我需要对我的所有org-mode文件执行revert buffer操作，
这样才能够获在buffer中显示更新的文件内容。

曾经我使用 =org-revert-all-org-buffers= 但是自从我发现 =global-auto-revert-mode=
之后，我就不再使用原来方法了。使用新的方法，只要缓冲区内容和硬盘中文件内容不一致，
缓冲区就会自动revert buffer。

这个模式对于我这种跨系统使用org-mode文件非常实用。

#+header: :tangle yes
#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src

** 加密处理
:PROPERTIES:
:CUSTOM_ID: HandlingEncryption
:END:

我曾经将加密数据，比如说账户密码的保存到单独的GPG加密文件中。现在这些数据都放到
org-mode文件中，并添加特别的标签。这样加密数据就可以保留在org-mode文件中。

=org-crypt= 允许给任务添加一个特别的 =crypt= 标签，org-模式就会将这个标题中
的数据加密。当需要查看加密数据你也可以對它解密，但是只要你再次保存文件，org-mode
会重新对它加密。

如下是对加密的一些配置:
#+header: :tangle yes
#+begin_src emacs-lisp
(require 'org-crypt)
; Encrypt all entries before saving
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
; GPG key to use for encryption
(setq org-crypt-key "F0B66B40")
#+end_src

=M-x org-decrypt-entry= 会弹出一个提示输入与你加密相关的密码，当正确后就用
明文来替代原来加密的密文。相反，加密并不需要输入密码-只要找到明文数据即可。

我习惯每个org文件都有个加密标题(像 =* Passwords=). 我阻止带 =crypt= 标签的任务
被继承，因为不希望加密数据中包含加密数据。 我发现当执行 =M-x org-decrypt-entries=
都输入解密密码（每次一个任务项执行一次）不方便。
我会对我的数据项加密直到我想查看他们为止-我根据实际需要选择解密，然后保存文件再次加密。
这样能保证数据明文出现时间尽可能短。

*** 自动保存文件
:PROPERTIES:
:CUSTOM_ID: AutoSaveFiles
:END:

emacs会临时保存缓冲区的内容到自动保存文件中，当你再编辑你的org缓冲区，并积累足够次数
后进行实际保存。 如果你的缓冲区中有解码的明文并还没有保存，那么这些明文将会写入这些临时自动保存
文件中，有可能会泄露些敏感信息。为防止这种情况，可以禁用自动保存功能。

个人来说，我非常喜欢自动保存功能。 99%情况我的加密项是安全的，因为他们一直都是处于加密
状态。 我通常会解密数据项后，立即通过快捷键 =C-x C-s= 保存文件，这样明文又会得到加密。
这就可以阻止自动保存文件中存在明文这种情况。

我的org crypt自动保存功能设置如下：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-crypt-disable-auto-save nil)
#+end_src

** 加速命令
:PROPERTIES:
:CUSTOM_ID: SpeedCommands
:END:

org-mode有个非常让人兴奋的功能叫做 =org-speed-commands=.

加速命令允许在标题行开始处访问经常使用的命令-很像agenda中的1键命令。加速命令
可以自行配置，org-mode提供了些默认的命令。

我在默认基础上有添加了一些如下的加速键。我不怎么使用优先级，因此我重写了1,2,3
键的默认设置。我同样禁用了'c'同时加了'q'用来快速回到agenda视图并更新视图。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-use-speed-commands t)
(setq org-speed-commands-user (quote (("0" . ignore)
                                      ("1" . ignore)
                                      ("2" . ignore)
                                      ("3" . ignore)
                                      ("4" . ignore)
                                      ("5" . ignore)
                                      ("6" . ignore)
                                      ("7" . ignore)
                                      ("8" . ignore)
                                      ("9" . ignore)

                                      ("a" . ignore)
                                      ("d" . ignore)
                                      ("h" . bh/hide-other)
                                      ("i" progn
                                       (forward-char 1)
                                       (call-interactively 'org-insert-heading-respect-content))
                                      ("k" . org-kill-note-or-show-branches)
                                      ("l" . ignore)
                                      ("m" . ignore)
                                      ("q" . bh/show-org-agenda)
                                      ("r" . ignore)
                                      ("s" . org-save-all-org-buffers)
                                      ("w" . org-refile)
                                      ("x" . ignore)
                                      ("y" . ignore)
                                      ("z" . org-add-note)

                                      ("A" . ignore)
                                      ("B" . ignore)
                                      ("E" . ignore)
                                      ("F" . bh/restrict-to-file-or-follow)
                                      ("G" . ignore)
                                      ("H" . ignore)
                                      ("J" . org-clock-goto)
                                      ("K" . ignore)
                                      ("L" . ignore)
                                      ("M" . ignore)
                                      ("N" . bh/narrow-to-org-subtree)
                                      ("P" . bh/narrow-to-org-project)
                                      ("Q" . ignore)
                                      ("R" . ignore)
                                      ("S" . ignore)
                                      ("T" . bh/org-todo)
                                      ("U" . bh/narrow-up-one-org-level)
                                      ("V" . ignore)
                                      ("W" . bh/widen)
                                      ("X" . ignore)
                                      ("Y" . ignore)
                                      ("Z" . ignore))))

(defun bh/show-org-agenda ()
  (interactive)
  (if org-agenda-sticky
      (switch-to-buffer "*Org Agenda( )*")
    (switch-to-buffer "*Org Agenda*"))
  (delete-other-windows))
#+end_src

变量 =org-speed-commands-default= 设置了很多加速键。 我使用最多的键是
=I= =O= 用来计时以及 =t=修改任务状态。

=J= 跳到当前或者上个计时任务。

=c= 以及 =C= 被禁用了，因此当输入这些字符时，字符就会插入进去。我用 =TAB= 以及 =S-TAB=来循环
折叠-所以我不需要 =c= =C=. =TAB= 可以在任何地方工作但是 =c= =C= 只能在标题
行才能执行，有时候我还会误碰。

** org 协议
:PROPERTIES:
:CUSTOM_ID: OrgProtocol
:END:

[[http://orgmode.org/worg/org-contrib/org-protocol.php][Org protocol]]方便从其他应用中为org-mode创建捕获的备忘。
我使用这个方法来记录下我在firefox浏览过的网页。

我有个特殊捕获模板用作 org-protocol使用(设置到 =w= 键)。

我的org-protocol设置非常简单。它能够使用org-protocol并且像[[#CaptureTemplates][Capture Templates]]描述那样
创建一个捕获模板。

#+header: :tangle yes
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src

另一部分设置是在firefox中，这样在firefox中执行 =C-c c就可以触发org-protocol，捕获我当前
在浏览网页。

** 保存文件时在文件末尾添加新行
:PROPERTIES:
:CUSTOM_ID: RequireFinalNewline
:END:

下面的设置主要用在编辑yasnippets, 当我希望在同一行，扩展代码片段时。
我只用这个功能在会议备忘中，替换字符串以及初始化一些人名。我现在使用 =abbrev=mode=
目前不使用这个设置了。

#+header: :tangle no
#+begin_src emacs-lisp
(setq require-final-newline nil)
#+end_src


当我想在emacs中保存一个文件时，我希望新添加新行-这个对我所工作的项目源码非常有好处。
这些是我的现在设置：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq require-final-newline t)
#+end_src

** 插入不活动的时间戳并排除在导出之外
:PROPERTIES:
:CUSTOM_ID: InsertInactiveTimestamps
:END:

当我工作在org-mode文件时候，我会插入不活跃的时间戳。
对于记忆任务时间戳，是在记忆模板中的，但是对于正常编辑大纲时候，我希望时间戳能够自行添加。

我定义个可以运行在org-mode的hook，当任务标题创建时，自动插入不活动的时间。

可以用 =f9 T= 来控制标题时间戳创建开关。

#+header: :tangle yes
#+begin_src emacs-lisp
(defvar bh/insert-inactive-timestamp t)

(defun bh/toggle-insert-inactive-timestamp ()
  (interactive)
  (setq bh/insert-inactive-timestamp (not bh/insert-inactive-timestamp))
  (message "Heading timestamps are %s" (if bh/insert-inactive-timestamp "ON" "OFF")))

(defun bh/insert-inactive-timestamp ()
  (interactive)
  (org-insert-time-stamp nil t t nil nil nil))

(defun bh/insert-heading-inactive-timestamp ()
  (save-excursion
    (when bh/insert-inactive-timestamp
      (org-return)
      (org-cycle)
      (bh/insert-inactive-timestamp))))

(add-hook 'org-insert-heading-hook 'bh/insert-heading-inactive-timestamp 'append)
#+end_src

每次我通过 =M-RET= 或者 =M-S-RET=创建标题时，hook调用此函数，然后就会插入不活动的时间戳

#+begin_src org :exports src
,* <point here>
  [2009-11-22 Sun 18:45]  
#+end_src
这个会记录下任务什么时候会被创建，我觉得这个功能非常有用。

我也为这个函数定义了快捷键，因此我就可以按需要插入不活动的时间戳。

#+header: :tangle no
#+begin_src emacs-lisp
(global-set-key (kbd "<f9> t") 'bh/insert-inactive-timestamp)
#+end_src

为阻止时间戳被导出到文档中，我使用下面的设置。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-export-with-timestamps nil)
#+end_src

** 链接上回车
:PROPERTIES:
:CUSTOM_ID: ReturnFollowsLink
:END:

下面设置使得 =RET= 插入新行，而不是打开链接。这个功能我是既爱又恨。当这个功能被
发现时，我首先将其关闭，因为我想在我的链接上插入新行，但是 =RET= 将会打开链接令人
很烦恼。然后我重新训练自己手指，在上一行结束按回车来创建新行。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-return-follows-link t)
#+end_src

** 超时时高亮显示时钟信息
:PROPERTIES:
:CUSTOM_ID: HighlightClockOvertime
:END:

目前计时信息显示在modeline。如果有预估时间，并且我们超时执行了，我让modeline着重
显示红色，通过下面设置：

#+header: :tangle yes
#+begin_src emacs-lisp
(custom-set-faces
  ;; custom-set-faces was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(org-mode-line-clock ((t (:foreground "red" :box (:line-width -1 :style released-button)))) t))
#+end_src

** 会议备忘
:PROPERTIES:
:CUSTOM_ID: MeetingNotes
:END:

我用org-mode来做会议备忘。我使用org-mode点形式来记录会议会话。如果一个执行项
在会上决定去完成我会用句点好标记出来，并添加TODO:或者DONE：标记。

会议也是一个任务，当会议完成任务也完成。任务内容记录会议上所有细节。如果任务上提到
新任务，我会创建另一个新的TODO任务。

我使用 =bh/prepare-meeting-notes= 来准备会议备忘,用来发给会议参与者(用固定
宽度字体像“Courier New”). 当会议结束，备忘也就可以发送了--所以不需要花费额外的
时间来重写他们。我也不排斥HTML格式输出--内容比格式更加重要。

#+begin_src org :exports src
,* TODO Sample Meeting
  - Attendees
    - [ ] Joe
    - [X] Larry
    - [X] Mary
    - [X] Fred
  - Joe is on vacation this week
  - Status Updates
    + Larry
      - did this
      - and that
      - TODO: Needs to follow up on this
    + Mary
      - got a promotion for her recent efforts
    + Fred
      - completed all his tasks 2 days early
      - needs more work
      - DONE: everything  
#+end_src

#+begin_src org :exports src
,* TODO Sample Meeting
   - Attendees
     - [ ] Joe
     - [X] Larry
     - [X] Mary
     - [X] Fred
   - Joe is on vacation this week
   - Status Updates
     + Larry
       - did this
       - and that
>>>>>>>> TODO: Needs to follow up on this
     + Mary
       - got a promotion for her recent efforts
     + Fred
       - completed all his tasks 2 days early
       - needs more work
>>>>>>>> DONE: everything  
#+end_src

下面是格式函数。高亮备忘并将TABs转换成空格，高亮todo项。会议纪要同时会保存进删除缓冲区，这样就方便将内容贴到其他应用中。

#+header: :tangle yes
#+begin_src emacs-lisp
(defun bh/prepare-meeting-notes ()
  "Prepare meeting notes for email
   Take selected region and convert tabs to spaces, mark TODOs with leading >>>, and copy to kill ring for pasting"
  (interactive)
  (let (prefix)
    (save-excursion
      (save-restriction
        (narrow-to-region (region-beginning) (region-end))
        (untabify (point-min) (point-max))
        (goto-char (point-min))
        (while (re-search-forward "^\\( *-\\\) \\(TODO\\|DONE\\): " (point-max) t)
          (replace-match (concat (make-string (length (match-string 1)) ?>) " " (match-string 2) ": ")))
        (goto-char (point-min))
        (kill-ring-save (point-min) (point-max))))))
#+end_src

** 修改后移除高亮
:PROPERTIES:
:CUSTOM_ID: HighlightPersistAfterEdit
:END:

我发现当我需要在org文件中查找一些细节时候，我会通过快捷键=C-c / /= 使用使用org-occur
查找内容.下面设置保持查找结果高亮，即使内容被修改，依然高亮。这使得我可以直接修改文件而
不丢失高亮，当修改完成后，可以继续下个匹配项。 =C-c C-c= 移除所有的高亮。

#+header: :tangle no
#+begin_src emacs-lisp
(setq org-remove-highlights-with-change nil)
#+end_src

设置这个参数为t时，当修改缓冲区，高亮将不再。

我已经开始使用当修改缓冲区后自动移除高亮，因为现在使用通用的 =M-x occur= 在emacs
缓冲区中查找。

** 获取最新的org-mode帮助文档
:PROPERTIES:
:CUSTOM_ID: OrgModeInfoDocumentation
:END:

我使用git仓库中的org-mode帮助文档，因此我设置emacs从git查找帮助文档，之后才常规查找
（过时）系统版本文档。

#+header: :tangle yes
#+begin_src emacs-lisp
(add-to-list 'Info-default-directory-list "~/git/org-mode/doc")
#+end_src

** 选择将来时间吗？
:PROPERTIES:
:CUSTOM_ID: FutureDates
:END:

默认情况下org会选择将来的某个时间。这意味着如果当前时间是5月2号，然后你输入一个
4月30号日期（2天前），org-mode将会跳转到明年的4月30号。我发现这个非常烦，因为
当我需要看看上周五发生什么我必须输入年。现在我训练我的手指，这样，如果需要查看以前
的信息我可以用快捷键 =b= ，所以这个问题对我来说也不是什么问题了。

** 自动修改点句
:PROPERTIES:
:CUSTOM_ID: ListBullets
:END:

在开会时候我会使用点格式。跟其他的list点句一样，这样当层级超过3行，就会让读取
细节变得更难。

当修改层级时，org-mode可以自动修改list点句。

| Current List Bullet | Next indented list bullet |
|---------------------+---------------------------|
| +                   | -                         |
| *                   | -                         |
| 1.                  | -                         |
| 1)                  | -                         |
| A)                  | -                         |
| B)                  | -                         |
| a)                  | -                         |
| b)                  | -                         |
| A.                  | -                         |
| B.                  | -                         |
| a.                  | -                         |
| b.                  | -                         |

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet (quote (("+" . "-")
                                            ("*" . "-")
                                            ("1." . "-")
                                            ("1)" . "-")
                                            ("A)" . "-")
                                            ("B)" . "-")
                                            ("a)" . "-")
                                            ("b)" . "-")
                                            ("A." . "-")
                                            ("B." . "-")
                                            ("a." . "-")
                                            ("b." . "-"))))
#+end_src

** 删除agenda标签视图中的缩进
:PROPERTIES:
:CUSTOM_ID: IndentationOnTagsView
:END:

我不喜欢agenda视图中对匹配的标签子层级缩进显示，当我执行agenda标签查询(=F12 m=），
我只希望看到所有匹配的任务（包含子层级）。

为使得所有匹配的大纲都在agenda显示，可以设置如下变量：

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-tags-match-list-sublevels t)
#+end_src

** 加固源码显示
:PROPERTIES:
:CUSTOM_ID: FontifySrcBlocksNatively
:END:

我使用babel来在我的文档中包含源码

#+begin_src org :exports src
,#+begin_src LANG
,,  ...
,#+end_src
#+end_src

LANG代表使用的语言(ditaa, dot, sh, emacs-lisp等)这将使得在org-mode中以代码块显示，同样导出文档时也是以
代码块显示。

可以查看这个文档[[#git-sync][Git Repository synchronization]] 作为个例子。

** 持久化agenda过滤器
:PROPERTIES:
:CUSTOM_ID: AgendaPersistentFilters
:END:

这是一个伟大功能！持久化agenda过滤器意味着当通过 =/ TAB SomeTag= 查看后agenda
会记住这个过滤条件，直到你修改它。

通过如下参数可以启动持久化过滤器

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-persistent-filter t)
#+end_src

** 为标记项添加标记
:PROPERTIES:
:CUSTOM_ID: TagFlaggedEntries
:END:

每个人都会碰到有些非常重要的信息，需要后续能够快速找到。

像这种备忘以及任务我添加了特殊的 =：FLAGGED：= 标记。这个标记有个快速按键 =？= 将会
在agenda中查找标记项。可以查看 [[#OrgTagAlist][Tags]]了解如何为 =FLAGGED= 项
设置 =org-tag-alist= 。

为查找标记项也非常简单，只要执行快捷键 =F12 ?= 就能获得。

** 使用compose-mail打开邮件链接
:PROPERTIES:
:CUSTOM_ID: MailLinksOpenComposeMail
:END:

下列设置使得org-mode 可以使用compose-mail打开 =mailto:= 链接。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-link-mailto-program (quote (compose-mail "%a" "%s")))
#+end_src

** org mode任务来作为邮件内容发送
:PROPERTIES:
:CUSTOM_ID: MailingSubtrees
:END:

可以创建基于org-mode子树内容的邮件。我通常使用 =C-c M-o= 来启动email消息，并从
子树获取内容，作为email邮件内容。我使用这种方式来处理重复的提醒任务，并需要发邮件
给别人。email内容已经包含在org-mode子树中，我只需要对子树执行 =C-c M-o= 然后
只要在发出前做稍许修改即可。

**使用smex作为 M-x ido-completion后端
:PROPERTIES:
:CUSTOM_ID: SmexAndIdo
:END:

我发现smex，并使用它作为IDO-completion 后端，当读取org-mode邮件列表后。我实际上会
执行M-x很多次，因为通过IDO补全方便。

下面是我的设置：

#+header: :tangle yes
#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "~/.emacs.d"))
(require 'smex)
(smex-initialize)

(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "C-x x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+end_src

** 使用emacs书签来快速导航
:PROPERTIES:
:CUSTOM_ID: BookmarksFastNavigation
:END:

我开始使用emacs书签来保存位置，以方便通过标签自动返回。通常我想回到当前计时任务，这很简单-只要执行 =F11= 。
当我在查看列表，对任务设置一个书签，就可以快速跳转到该列表处理，当完成后，可以快速回到任务，然后将它的
复选框标记上。

我emacs书签相关设置如下：

#+header: :tangle yes
#+begin_src emacs-lisp
;; Bookmark handling
;;
(global-set-key (kbd "<C-f6>") '(lambda () (interactive) (bookmark-set "SAVED")))
(global-set-key (kbd "<f6>") '(lambda () (interactive) (bookmark-jump "SAVED")))
#+end_src

当我想保存当前位置，我只需要执行快捷键 =C-f6= ，当我想返回，我只需要执行 =f6= .我会每次
重写这个标签来设置新位置。

** 使用org-mime发邮件
:PROPERTIES:
:CUSTOM_ID: OrgMimeMail
:END:

我现在正在使用通过mime来发送org相关邮件。我在 =org-mode-hook= 添加了 =C-c M-o= 按键绑定来从
org子树生成邮件。

** 从agenda中移除多个状态切换日志
:PROPERTIES:
:CUSTOM_ID: StateChangeDetailsInAgenda
:END:

我在agenda视图中通过如下视图，跳过相同任务项包含多个时间戳这种情况。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-skip-additional-timestamps-same-entry t)
#+end_src

这样可以移除多于的状态转换log当多个时间戳存在于一个任务项中。

** 在表格中舍弃老的引用格式
:PROPERTIES:
:CUSTOM_ID: OldTableReferences
:END:

我通过如下设置,舍弃了表格中老的 A3/B4格式引用。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-table-use-standard-references (quote from))
#+end_src

** 使用系统设置来完成file-application选择
:PROPERTIES:
:CUSTOM_ID: SystemSettingsForApplicationSelection
:END:

为使任务打开方式体验一致，我会像如下方式设置 =org-file-apps= .

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-file-apps (quote ((auto-mode . emacs)
                            ("\\.mm\\'" . system)
                            ("\\.x?html?\\'" . system)
                            ("\\.pdf\\'" . system))))
#+end_src

当打开文件文件时，它使用定义在我系统 =mailcap= 中的项目设置，这使得我，在通过 =C-c C-o=
打开一些HTML链接时候有一致体验。

** 复制时删除ID
:PROPERTIES:
:CUSTOM_ID: DeleteIdsWhenCloning
:END:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-clone-delete-id t)
#+end_src

** 折叠文本列表
:PROPERTIES:
:CUSTOM_ID: CyclePlainLists
:END:

org mode能够折叠（展开）文本列表。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-cycle-include-plain-lists t)
#+end_src

我发现当我的重复任务包含很多复选框子列表时，这个功能非常有用。我可以折叠起完成项，并只关注那些还没有完成的。

** 代码块语法高亮
:PROPERTIES:
:CUSTOM_ID: ShowSrcBlockSyntax
:END:

在org-mode中可以显示native形式的源码。这可以高亮 C以及shell脚本源码。当我要
标记源码，我使用 =C-c '=(control-c单引号)会打开源码窗口，源码也会高亮。这个
设置也会将org-mode缓冲区的语法高亮。

** 插入代码块模板
:PROPERTIES:
:CUSTOM_ID: StructureTemplateBlocks
:END:

在org-mode中有一些快捷键用来快速插入代码块模板。

我在org中使用example以及代码块非常多

| Key Sequence | Expands to                        |
|--------------+-----------------------------------|
| < s TAB      | #+begin_src ... #+end_src         |
| < e TAB      | #+begin_example ... #+end_example |

我添加了一个代码模板块用来从MS outlook中拷贝内容到我的org-mode任务。

下面的lisp在org-mode中将默认将字符转化成小写。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-structure-template-alist
      (quote (("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
              ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
              ("v" "#+begin_verse\n?\n#+end_verse" "<verse>\n?\n</verse>")
              ("c" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
              ("l" "#+begin_latex\n?\n#+end_latex" "<literal style=\"latex\">\n?\n</literal>")
              ("L" "#+latex: " "<literal style=\"latex\">?</literal>")
              ("h" "#+begin_html\n?\n#+end_html" "<literal style=\"html\">\n?\n</literal>")
              ("H" "#+html: " "<literal style=\"html\">?</literal>")
              ("a" "#+begin_ascii\n?\n#+end_ascii")
              ("A" "#+ascii: ")
              ("i" "#+index: ?" "#+index: ?")
              ("I" "#+include %file ?" "<include file=%file markup=\"?\">"))))
#+end_src

** NEXT状态只适用于任务
:PROPERTIES:
:CUSTOM_ID: NextTasks
:END:

=NEXT= 任务只适用 *tasks* 并不适用 *projects* 。我写了个函数来处理状态改变，以及当子任务
状态变成 =NEXT= ，会将父任务从 =NEXT= 转换成 =TODO= ，因为父任务是项目，并不是任务。

** 默认折叠模式显示
:PROPERTIES:
:CUSTOM_ID: StartupView
:END:

启动时显示折叠模式

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-startup-folded t)
#+end_src

我以前使用内容模式，因此可以在归档前查看子树内容，但是我的归档流程已经修改了，
因此我不需要这步了。

** 只允许字符类表项
:PROPERTIES:
:CUSTOM_ID: AlphabeticalLists
:END:

下列设置添加如下的字符列表

#+begin_src org :exports src
a. item one
b. item two
#+end_src

#+header: :tangle no
#+begin_src emacs-lisp
(setq org-alphabetical-lists t)
#+end_src

为使得能正常工作，这个需要在exporter之前设置。

** 使用orgstruct 发邮件
:PROPERTIES:
:CUSTOM_ID: OrgStructModeForMail
:END:

=orgstruct++-mode= 在 =Gnus= 消息缓冲区开启，用以创建结构化邮件消息。

#+header: :tangle yes
#+begin_src emacs-lisp
(add-hook 'message-mode-hook 'orgstruct++-mode 'append)
(add-hook 'message-mode-hook 'turn-on-auto-fill 'append)
(add-hook 'message-mode-hook 'bbdb-define-all-aliases 'append)
(add-hook 'message-mode-hook 'orgtbl-mode 'append)
(add-hook 'message-mode-hook 'turn-on-flyspell 'append)
(add-hook 'message-mode-hook
          '(lambda () (setq fill-column 72))
          'append)
#+end_src

** 使用flyspell mode减少拼写错误
:PROPERTIES:
:CUSTOM_ID: FlySpellModeChecksSpelling
:END:

=flyspell-mode= 默认在任何模式都开启，用来检查文档中包含拼写错误。

#+header: :tangle yes
#+begin_src emacs-lisp
;; flyspell mode for spell checking everywhere
(add-hook 'org-mode-hook 'turn-on-flyspell 'append)

;; Disable keys in org-mode
;;    C-c [ 
;;    C-c ]
;;    C-c ;
;;    C-c C-x C-q  cancelling the clock (we never want this)
(add-hook 'org-mode-hook
          '(lambda ()
             ;; Undefine C-c [ and C-c ] since this breaks my
             ;; org-agenda files when directories are include It
             ;; expands the files in the directories individually
             (org-defkey org-mode-map "\C-c[" 'undefined)
             (org-defkey org-mode-map "\C-c]" 'undefined)
             (org-defkey org-mode-map "\C-c;" 'undefined)
             (org-defkey org-mode-map "\C-c\C-x\C-q" 'undefined))
          'append)

(add-hook 'org-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c M-o") 'bh/mail-subtree))
          'append)

(defun bh/mail-subtree ()
  (interactive)
  (org-mark-subtree)
  (org-mime-subtree))
#+end_src

** 维持源码块对齐
:PROPERTIES:
:CUSTOM_ID: PreserveSourceIndentations
:END:

我不会在源码块中维持对齐，因为这样看起来不是很好。唯一一个我觉得需要保留对齐是在文件中
的TABs需要保留(例如 Makefiles)。我不怎么在org-mode编辑这种文件，所以我默认将对齐关闭。

我修改了默认代码块对齐方式，这样就不会从文本开始对齐。这允许立即编辑源码而不需要执行
=C-c '= ，因此代码看上去就正确了。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-src-preserve-indentation nil)
(setq org-edit-src-content-indentation 0)
#+end_src

** 阻止修改不可见文档
:PROPERTIES:
:CUSTOM_ID: PreventInvisibleEdits
:END:

当光标在折叠去，下面设置阻止不小心修改隐藏文档。这种情况会发生在当光标在标题体内，然后通过
执行 =S-TAB= 折叠org文件。

我发现不可见编辑（撤销）很难处理，因此现在我禁止编辑不可见文本。 =C-c C-r= (org-reveal) 将会
显示光标，当光标折叠在不可见区域时，这样就可以编辑了。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'error)
#+end_src

** 使用utf-8作为默认文字编码
:PROPERTIES:
:CUSTOM_ID: DefaultCodingSystem
:END:

我对我所有的org文件使用 =utf-8= 作为默认编码格式。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-export-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(set-charset-priority 'unicode)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src

** 使用小时来计时
:PROPERTIES:
:CUSTOM_ID: ClockDurationsNoDays
:END:

默认计时时长变成以24小时每日计时。工作中我通常认为一天有6小时来工作(其它时间用在
开会以及其他事情上)所以以日计时对我来说没有什么意义。

下列设置修改计时为以小时以及分钟来计时(=C-c C-x C-d= )

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-time-clocksum-format
      '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))
#+end_src

** 创建唯一ID为任务做链接
:PROPERTIES:
:CUSTOM_ID: LinkingToTaskCreatesId
:END:

当设置下面设置后，使用 =C-c l=, 就会为标题在 =PROPERTY= 属性抽屉中，创建唯一ID.
当有了唯一ID，我即使将任务在文档中移动，链接到该任务的链接依然有效。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
#+end_src

* 哪些我不再使用功能
:PROPERTIES:
:CUSTOM_ID: Unused
:END:

下面列了些我知道的功能，但是我不怎么用它们。
=org-mode= 包含大量功能。有很多功能我还不清楚或者说还没有暴露出来，所以这个
列表暂时还没有完成。

** 归档相同层级的子树
:PROPERTIES:
:CUSTOM_ID: ArchiveSibling
:END:

这个是个可笑的想法，但是我觉得归档整个子树更合适些。我不介意大量任务被标记
=DONE= (还没有归档)。

** 处理字符格式
:PROPERTIES:
:CUSTOM_ID: StrikeThroughEmphasis
:END:

当从其它文件拷贝文本到org-mode文件中，字符中的格式会使得文档可读性很差。通过如下设置，可以移除字符中格式，这样看上
去更好点。

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-emphasis-alist (quote (("*" bold "<b>" "</b>")
                                 ("/" italic "<i>" "</i>")
                                 ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
                                 ("=" org-code "<code>" "</code>" verbatim)
                                 ("~" org-verbatim "<code>" "</code>" verbatim))))
#+end_src

** 下标以及上标
:PROPERTIES:
:CUSTOM_ID: SubscriptsAndSuperscripts
:END:

我目前不会写些需要下标以及上标的文档。我通过下面方法禁用 =_=  以及 =^= .

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-use-sub-superscripts nil)
#+end_src

** Yasnippet
:PROPERTIES:
:CUSTOM_ID: Yasnippets
:END:

[[http://code.google.com/p/yasnippet/][Yasnippet]] 很棒，但是我不怎么用了。我使用 =abbrev-mode=
以及 =skeletons= 来替换yasnippet,并且他们默认在emacs中就可用的。

Yasnippet 包含很多代码语言片段。我在 =org-mode= 中使用少量的babel相关的代码片段。

我下载安装了非绑定的版本的yasnippet，这样我就可以编辑预定义的代码片段。我将yasnippet
解压到我的 =~/.emacs.d/plugins= 目录，重命名 =yasnippet0.5.10= 为 =yasnippet=
然后添加进我的 =.emacs=中。

我是这么使用代码片段：
    - =begin= 来生成 =#+begin= 块
    - =dot= 生成 graphviz
    - =uml= 生成 PlantUML图
    - =sh= 生成 bash shell 脚本
    - =elisp= 生成emacs lisp 脚本
    - 当开会是记录会议备忘时用来转换参会者全名

下面是 =begin= 代码块定义：
org-mode Yasnippet: ~/.emacs.d/plugins/yasnippet/snippets/text-mode/org-mode/begin

:  #name : #+begin_...#+end_
:  # --     
:  #+begin_$1 $2
:  $0
:  #+end_$1

我这样创建 =#+begin_**= 代码块
- =#+begin_example=
- =#+begin_src=
- 其他。

输入 =begin= 然后按 =TAB= 然后 =begin= 文本就会替换成代码段。当输入
=src TAB emacs-lisp TAB= 代码块就完成了。我将这个流程缩减成 =elisp TAB=
因为我经常用。

输入 =C-c SingleQuote(')= 就会插入你需要的emacs-lisp 代码。
当进入这个块中，你就可以在一种你知道的格式以及相应着色的emacs lisp 脚本，非常
好。 =C-c SingleQuote（‘）= 退回到org-mode。它可以识别任何emacs编辑模式，
所以你只需要输入合适的mode名称即可。

=dot=
: #dot : #+begin_src dot ... #+end_src
: # --
: #+begin_src dot :file $1 :cmdline -Kdot -Tpng
: $0
: #+end_src

=uml=
: #uml : #+begin_src plantuml ... #+end_src
: # --
: #+begin_src plantuml :file $1
: $0
: #+end_src

=sh=
: #sh: #+begin_src sh ... #+end_src
: # --
: #+begin_src sh :results output
: $0
: #+end_src


=elisp=
: #elisp : #+begin_src emacs-lisp ...#+end_src emacs-lisp
: # --
: #+begin_src emacs-lisp
: $0
: #+end_src

节省了非常多时间。

** 只在奇数行或者偶数行显示标题
:PROPERTIES:
:CUSTOM_ID: HeadingLevelsOddEven
:END:

这个我已经使用org-indent-mode替换了。

我使用函数 =org-convert-to-odd-levels= 以及 =org-covert-to-oddeven-levels= 函数
转换成奇数行或者偶数行。我最终会设置为奇偶行，这样可以减少任务上的空格。我不觉得只显示奇数行
很好，当然全部显示也不是特别好。

** 同时设置父任务STARTED状态
:PROPERTIES:
:CUSTOM_ID: PropagateStartedToParent
:END:

我曾经既使用 =STARTED= 又使用 =NEXT= 状态。大部分情况来说他俩一个意思，唯一区别就是
=STARTED= 可以表示任务刚开始计时。然后我就会将该任务设置成 =NEXT= 状态。

下面代码用来将 =STARTED= 状态同时应用在父任务上，但是目前我不这么用了。

当一个任务被标记成 =STARTED= 状态(不管是手工还是计时器)，那么它的父任务如果在 =TODO=
或者 =NEXT= 时候就会被标记成 =STARTED= 状态。只要对第一个 =NEXT= 子任务标记成 =STARTED=
那么父任务也会一样被标记。这能帮我跟踪正在进行的任务。

下面是这个功能的实现：

#+header: :tangle no
#+begin_src emacs-lisp
;; Mark parent tasks as started
(defvar bh/mark-parent-tasks-started nil)

(defun bh/mark-parent-tasks-started ()
  "Visit each parent task and change TODO states to STARTED"
  (unless bh/mark-parent-tasks-started
    (when (equal org-state "STARTED")
      (let ((bh/mark-parent-tasks-started t))
        (save-excursion
          (while (org-up-heading-safe)
            (when (member (nth 2 (org-heading-components)) (list "TODO" "NEXT"))
              (org-todo "STARTED"))))))))

(add-hook 'org-after-todo-state-change-hook 'bh/mark-parent-tasks-started 'append)
#+end_src

** 自动计时任务
:PROPERTIES:
:CUSTOM_ID: AutomaticallyClockingTasks
:END:

我曾经在开源软件BZFlag做贡献。当需要发布时候，我会对测试BZFlag客户端计时。

我有个按键绑定在我的窗口管理器中，当执行该快捷键，就会对测试任务计时，并运行
BZFlag客户端，当完成，恢复之前的任务计时。

#+header: :tangle no
#+begin_src emacs-lisp
(defun bh/clock-in-bzflagt-task ()
  (interactive)
  (bh/clock-in-task-by-id "dcf55180-2a18-460e-8abb-a9f02f0893be"))
#+end_src

该函数通过shell脚本调用：

#+begin_src sh :results output
,#!/bin/sh
emacsclient -e '(bh/clock-in-bzflagt-task)'
~/git/bzflag/trunk/bzflag/src/bzflag/bzflag -directory ~/git/bzflag/trunk/bzflag/data $*
emacsclient -e '(bh/resume-clock)'
#+end_src

恢复计时函数将计时器应用到之前的计时任务上。

#+header: :tangle no
#+begin_src emacs-lisp
(defun bh/resume-clock ()
  (interactive)
  (if (marker-buffer org-clock-interrupted-task)
      (org-with-point-at org-clock-interrupted-task
        (org-clock-in))
    (org-clock-out)))
#+end_src

如果没有任务通过 =bh/resume-clock= 停止计时。

** 按键q隐藏agenda视图缓冲区
:PROPERTIES:
:CUSTOM_ID: QBuriesAgenda
:END:

通过 [[#StickyAgendas][Sticky Agendas]] ，q键默认行为就是退出缓冲区，因此这个目前
暂时不需要了。

我修改了agenda中 =q= 按键，替换关闭agenda 缓冲区，取而代之将其放入buffer list最尾端。
这样我就可以使用 =q= 来快速将agenda视图切换回来，或者通过 =f9 f9=重新生成agenda视图。

#+header: :tangle no
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook
          (lambda ()
            (define-key org-agenda-mode-map "q" 'bury-buffer))
          'append)
#+end_src

** 任务优先级
:PROPERTIES:
:CUSTOM_ID: TaskPriorities
:END:

我使用agenda来选择下个需要做的任务。通常我不会用优先级来处理，但是在工作中
我会从我的经理那边获取有些优先级搞的任务。这种情况我会将这个任务标记成高优先级。
这时会让agenda按照优先级来显示任务。

我使用A-E来标记任务优先级，没有明确标记的任务使用最低的E优先级。

#+header: :tangle no
#+begin_src emacs-lisp
(setq org-enable-priority-commands t)
(setq org-default-priority ?E)
(setq org-lowest-priority ?E)
#+end_sr

* 使用git来同步历史，备份以及同步数据
:PROPERTIES:
:CUSTOM_ID: GitSync
:END:

修改org文件中折叠区域非常危险。我的做法是将org文件纳入 =git= 管理。

我的设置会每个小时保存所有的org文件，并自动创建commit。这方便我
及时回退并查看我的org状态，在文档生命周期期间。我使用这种方法来恢复
我不小心删除的折叠区域的数据。

** 自动定时提交
:PROPERTIES:
:CUSTOM_ID: HourlyCommits
:END:

我的emacs设置一小时前1分钟开始保存所有org缓冲区。代码包含在 =.emacs= 中

#+header: :tangle yes
#+begin_src emacs-lisp
(run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+end_src

=cron= 任务任务每小时通过 =org-save-all-org-buffers= 保存所有缓冲区。
我使用脚本来提交代码，因此我可以按需要提交代码，并当从一台机器移动到
另一台机器，方便拉取所有修改。

=crontab= 细节：
#+begin_example 
0 * * * * ~/bin/org-git-sync.sh >/dev/null
#+end_example

** ~/bin/org-git-sync.sh
:PROPERTIES:
:CUSTOM_ID: OrgGitSyncSh
:END:

下面是shell脚本来创建所有的 =git= 提交。该循环遍历多个仓库，提交所有修改的文件。我
有如下几个org-mode仓库。

- org
  所有org 项目文件以及todo列表
- doc-norang.ca
  所有 http://doc.norang.ca/ 下修改
- www.norang.ca
  网站 http://www.norang.ca/ 所有修改

下面脚本不会创建空commit - =git= 只会对有修改的才会创建commit.

#+begin_src sh
,#!/bin/sh
# Add org file changes to the repository
REPOS="org doc.norang.ca www.norang.ca"

for REPO in $REPOS
do
    echo "Repository: $REPO"
    cd ~/git/$REPO
    # Remove deleted files
    git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
    # Add new files
    git add . >/dev/null 2>&1
    git commit -m "$(date)"
done
#+end_src

我使用如下的 =.gitignore= 文件来在我的 =git= 仓库中排除自动生成的文件。
如果需要导入ditaa或者graphviz我将会将其加到我的repo总。默认情况下所有
PNG图像都被忽略(默认情况下我认为他们都是由 ditaa生成)

#+begin_example 
core
core.*
*.html
*~
.#*
\#*\#
*.txt
*.tex
*.aux
*.dvi
*.log
*.out
*.ics
*.pdf
*.xml
*.org-source
*.png
*.toc
#+end_example

** Git- 让编辑更加自信
:PROPERTIES:
:CUSTOM_ID: GitEditWithConfidence
:END:

我在我所有目录下都用git，这样我所有的更新都可以通过git来跟踪。

这意味着我可以很自信的修改文件。改文件，破坏文件对我来说也不是问题。
通常我也非常方便回退到之前版本，来查看修改了那些东西。当修改配置文件时候，也非常
方便（例如 apache webserver，bind9 DNS配置等。）

这非常方便，修改文件可能让破坏文件，但是如果有 =git= 来跟踪修改，那么你会很方便
快速找回之前版本。当然包更新也是可以用git来管理。

我将每个修改都保存在我的 =git= 仓库中。

** git仓库同步
:PROPERTIES:
:CUSTOM_ID: git-sync
:END:

我买了台 Eee PC 1000 HE作为我的主要工作电脑来替换我的6年的 Toshiba Tecra S1.

我有个LAN服务器作为我所有项目的git仓库。现在唯一的问题是我需要保留5分钟来保证我
所有的文档更新到最新，当我把它带出去(没有网络连接)。

为解决这个问题，我在上面建了个bare仓库。它包含我的org-mode仓库以及其他感兴趣的仓库。

当我需要出去，我会通过 =git-sync= 脚本将我的工作站的bare git仓库更新到我的
Eee PC上。对于merge冲突的仓库我先手动解决冲突，然后重新运行
=git-sync= 直到没有报错。这可能会花一到两分钟。然后我就可以带着我的Eee PC
离开。当我在路上，我就有所有的历史以及git仓库。

=git-sync= 脚本替换我之前的脚本，它里边包含所有用到的工具。它能够完成如下工作：

- 对于当前系统上的每个仓库
  - 从远程获取对象
  - 对每个分支跟踪远程分支
    - 检查ref能不能移动
    - 如果本地仓库比较老执行快速merge
    - 如果已经是最新的，什么都不需要处理
    - 提交修改到远程仓库
    - 当本地和远程有分支时，报错

这会使得我电脑上35个仓库自动更新，用最少的干预。我需要人工处理的只剩我在Eee PC以及
我的工作站修改冲突-- 这样就可以merge了。

下面是我的 =git-sync= 脚本。

#+begin_src sh
,#!/bin/sh
#

# Local bare repository name
syncrepo=norang
reporoot=~/git

# Display repository name only once
log_repo() {
  [ "x$lastrepo" == "x$repo" ] || {
    printf "\nREPO: ${repo}\n"
    lastrepo="$repo"
  }
}

# Log a message for a repository
log_msg() {
  log_repo
  printf "  $1\n"
}

# fast-forward reference $1 to $syncrepo/$1
fast_forward_ref() {
  log_msg "fast-forwarding ref $1"
  current_ref=$(cat .git/HEAD)
  if [ "x$current_ref" = "xref: refs/heads/$1" ]
  then
    # Check for dirty index
    files=$(git diff-index --name-only HEAD --)
    git merge refs/remotes/$syncrepo/$1
  else
    git branch -f $1 refs/remotes/$syncrepo/$1
  fi
}

# Push reference $1 to $syncrepo
push_ref() {
  log_msg "Pushing ref $1"
  if ! git push --tags $syncrepo $1
  then
    exit 1
  fi
}

# Check if a ref can be moved
#   - fast-forwards if behind the sync repo and is fast-forwardable
#   - Does nothing if ref is up to date
#   - Pushes ref to $syncrepo if ref is ahead of syncrepo and fastforwardable
#   - Fails if ref and $syncrop/ref have diverged
check_ref() {
  revlist1=$(git rev-list refs/remotes/$syncrepo/$1..$1)
  revlist2=$(git rev-list $1..refs/remotes/$syncrepo/$1)
  if [ "x$revlist1" = "x" -a "x$revlist2" = "x" ]
  then
    # Ref $1 is up to date.
    :
  elif [ "x$revlist1" = "x" ]
  then
    # Ref $1 is behind $syncrepo/$1 and can be fast-forwarded.
    fast_forward_ref $1 || exit 1
  elif [ "x$revlist2" = "x" ]
  then
    # Ref $1 is ahead of $syncrepo/$1 and can be pushed.
    push_ref $1 || exit 1
  else
    log_msg "Ref $1 and $syncrepo/$1 have diverged."
    exit 1
  fi
}

# Check all local refs with matching refs in the $syncrepo
check_refs () {
  git for-each-ref refs/heads/* | while read sha1 commit ref
  do
    ref=${ref/refs\/heads\//}
    git for-each-ref refs/remotes/$syncrepo/$ref | while read sha2 commit ref2
    do
      if [ "x$sha2" != "x" -a "x$sha2" != "x" ]
      then
        check_ref $ref || exit 1
      fi
    done
  done
}

# For all repositories under $reporoot
#   Check all refs matching $syncrepo and fast-forward, or push as necessary
#   to synchronize the ref with $syncrepo
#   Bail out if ref is not fastforwardable so user can fix and rerun
    time {
  retval=0
  if find $reporoot -type d -name '*.git' | { 
      while read repo
      do
        repo=${repo/\/.git/}
        cd ${repo}
        upd=$(git remote update $syncrepo 2>&1 || retval=1)
        [ "x$upd" = "xFetching $syncrepo" ] || {
          log_repo
          printf "$upd\n"
        }
        check_refs || retval=1
      done
      exit $retval
    }
  then
    printf "\nAll done.\n"
  else
    printf "\nFix and redo.\n"
  fi
}

exit $retval
#+end_src
